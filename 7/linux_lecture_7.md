## Розділ 7: Запуск простору користувача

Простір користувача починається приблизно в цьому порядку:

1. init

1. Основні служби низького рівня, такі як `udevd` та `syslogd`

1. Конфігурація мережі

1. Служби середнього рівня та високого рівня (`cron`, `printing` тощо)

1. Запрошення на вхід, GUI та інші високорівневі програми

### Вступ до `init`

Програма `init` -- це програма простору користувача, як і будь-яка інша програма в системі Linux, і ви знайдете її в _/sbin_ разом з іншими системними бінарними файлами. Основна її мета - запускати та зупиняти основні службові процеси в системі.

Є три основні реалізації:

- _System V init_: традиційна init (RHEL та інші)

- _systemd_: новий стандарт для init

- _Upstart_: колишня реалізація init на Ubuntu (замінена на systemd)

#### Завдання та принципи роботи

У Unix-подібних системах, існує головний системний процес, який завжди має PID=1, це система ініціалізації та управління службами.
Вона виконує певні важливі функції:

1. Завантаження системи — запуск та ініціалізацію всіх компонентів ОС (драйверів пристроїв і системних служб);

2. Управління службами — дає змогу запускати, зупиняти і перезапускати служби, і керувати їхньою конфігурацією;

3. Контроль подій і помилок — відстежує системні події та обробляє їх необхідним чином.

#### Хронологія розвитку

- Спочатку 1970-х років у класичних Unix системах використовувався процес ініціалізації _init_. Це досить просте рішення засноване на Shell-скриптах та послідовній їх обробці під час завантаження системи. Вона і досі зустрічається в Unix-системах.

- У 1984 році було створено Систему _rc_ Деном Берком (Dan Berks) для "BSD 4.2" (Berkeley Software Distribution). Вона стала частиною проекту BSD і альтернативою простої системи _init_, надалі вона увійшла у FreeBSD і його форки.

- На наприкінці 1980-х років, з'явилася _SysVinit_ (System V initialization). Як і системі _init/rc_, вона спирається на скрипти, розташовані в `/etc/rc.d/` або `/etc/rc` . У ній ввели поняття рівнів виконання runlevels , які задають стан системи і набір виконуваних служб.

- У 2006 році компанією Canonical створено _Upstart_, яка стала заміною _SysVinit_ і вперше з'явилася в Ubuntu 6.10. Вона була розроблялася з урахуванням багатопроцесорних систем і покращувала паралельний запуск служб. У ній так само впроваджено контроль подій і можливість реагувати на зміну станів системи. _Upstart_ використовує подієву модель ініціалізації, де запуск і зупинка служб засновані на подіях, а не на простому порядку запуску. Однак широкого поширення _Upstart_ так і не набув.

- У 2007 році розробник Gentoo, Рой Марплс (Roy Marples) представив світові _OpenRC_, як просту і легковажну заміну _SysVinit_. Вона дотримувалася принципів і концепцій системи ініціалізації BSD і сумісна з нею за структурою каталогів і скриптів. Зараз використовується в Gentoo і Alpine Linux.

- У 2010 році було представлено _systemd_, створену Леннартом Поттерінгом (Lennart Poettering), Кай Зіверс (Kay Siever) і колективом розробників (Red Hat). Це цілісна система ініціалізації, яка забезпечує паралельне завантаження, поліпшене логування, управління залежностями, автоматичну активацію служб під час запиту, засоби налагодження та моніторингу, а також інші додаткові функції. Стала
основною для багатьох дистрибутивів Linux, зокрема Ubuntu.

### System V Runlevels

At any given time on a Linux system, a certain base set of processes (such as crond and udevd) is running. In System V init, this state of the machine is called its runlevel, which is denoted by a number from 0 through 6. You can check your system’s runlevel with the `who -r` command.

### Identifying your init

- If your system has `/usr/lib/systemd` and `/etc/systemd` directories, you have _systemd_

- If you have an `/etc/init` directory that contains several `.conf` files, you’re probably running _Upstart_

- If neither of the above is true, but you have an `/etc/inittab` file, you’re probably running _System V init_

### systemd

The systemd init handles the regular boot process and aims to incorporate a number of standard Unix services (cron, inetd). It has the ability to defer the start of services and operating system features until they are necessary.

### System V RunLevels

У будь-який момент часу в системі Linux виконується певний базовий набір процесів (наприклад, `crond` і `udevd`). В ініціалізації System V цей стан машини називається її рівнем запуску (_RunLevel_), який позначається числом від 0 до 6. Ви можете перевірити рівень запуску вашої системи за допомогою команди `who -r`.

### Ідентифікація `init` системи

- Якщо у вашій системі є каталоги `/usr/lib/systemd` і `/etc/systemd`, у вас _systemd_

- Якщо у вас є каталог `/etc/init`, який містить кілька файлів `.conf`, ви ймовірно використовуєте _Upstart_

- Якщо жодне з наведених вище не відповідає дійсності, але у вас є файл `/etc/inittab`, ви ймовірно використовуєте _System V init_

### systemd

`systemd init` керує процесом завантаження системи та має на меті об’єднати ряд стандартних служб Unix (`cron`, `inetd`). Він також вміє відкладати запуск служб і функцій операційної системи, поки вони не знадобляться.

#### Переваги _systemd_

- Просунута підтримка паралельного запуску служб;

- Більш широкий набір функцій управління та моніторингу;

- Комплексний і сучасний підхід до управління системою в цілому.

При цьому його аналоги також застосовуються в деяких інфраструктурних рішеннях, наприклад у docker-контейнерах часто використовується Alpine Linux через легший _OpenRC_.

Подобнім функціональним аналгом у Windows є підсистема "Service Control Manager (SCM)" та її утиліти sc start , sc stop , sc query та інші.

#### Підсистема systemd

Systemd — центральна система ініціалізації та управління службами. Вона обробляє все, що виходить за рамки завдань ядра із запуску та
управління системою.

![systemd](./images/systemd.png)

Система ініціалізації _systemd_ використовується в CentOS-7+, Debian-8+, Ubuntu-15.04+, Fedora15+, openSUSE 12.1+.

### Базові поняття та терміни

Концепция _systemd_ базируется на управлении "юнитами" (unit). Через них описуються різні компоненти і стани системи, визначаються залежності та контролюється їхній запуск, зупинка і взаємодія.

    Unit — основна одиниця управління _systemd_.Це конфігураційний файл, що описує системний об'єкт: процес, ресурс або стан системи.

#### Базові типи юнітів

`.target` — (цільовий стан) абстракція, що групує інші юніти і визначає стан системи, що виникає під час запуску або перемикання
режимів.

```bash
# Перегляд усіх наявних у системі "Target Unit"
systemctl list-units - -all --type = target
```

Деякі приклади:

- `multi-user.target` — "Multi-User System", визначає активність служб, необхідних для багатокористувацької роботи

- `graphical.target` — "Graphical Interface", визначає готовність графічних інтерфейсів GNOME або KDE.

- `rescue.target` — "Bootup into Rescue mode", режим відновлення, визначає мінімальний набір служб для "порятунку" системи.

`.service` — (сервіс/служба) описує системний сервіс (демон), визначає команди запуску, зупинки та перезапуску сервісу, а також задає залежності та налаштування оточення.

```bash
# Перегляд усіх наявних у системі "Service Unit"
systemctl list-units --all --type=service
```

Деякі приклади:

- `ssh.service` — "OpenBSD Secure Shell server"

- `systemd-remount-fs.service` — "Remount Root and Kernel File Systems"

- `nginx.service` — "A high performance web server and a reverse proxy server"

`.timer` — (таймер завдань), заміна й аналог cron, визначає час запуску та інтервали повторення для виконання інших юнітів.

```bash
# Перегляд усіх наявних у системі "Timer Unit"
systemctl list-units --all --type=timer
```

Деякі приклади:

- `apt-daily-upgrade.timer` — "Daily apt upgrade and clean activities"

- `logrotate.timer` — "Daily rotation of log files"

- `mdmonitor-oneshot.timer` — "Reminder for degraded MD arrays"

`.mount` — (монтуємий ресурс), визначає диск або мережеву папку, тип файлової системи, точку монтування та інші параметри.

```bash
# Перегляд усіх наявних у системі "Mount Unit"
systemctl list-units --all --type=mount
```

Деякі приклади:

- `.mount` — "Root Mount"

- `proc-sys-fs-binfmt_misc.mount` — "Arbitrary Executable File Formats File System"

- `sys-kernel-config.mount` — "Kernel Configuration File System"

#### Інші типи юнітів

`.socket` — (юніт сокет), визначає мережевий або UNIX-сокет, який використовується для обміну даними між процесами та юнітами.

```bash
# Перегляд усіх наявних у системі "Socket Unit"
systemctl list-sockets
```

`.path` — (юніт шляху), дає змогу відстежувати зміни у файлах або директоріях і реагувати на них, активуючи пов'язані сервіси або інші
юніти.

`.slice` — (юніт зрізу), описує групу процесів або інших юнітів для застосування до них політик управління ресурсами процесора,
пам'яті або введення-виведення.

`.device` — (юніт пристрою), абстракція над фізичним або віртуальним пристроєм для налаштування параметрів, права доступу та
залежностей від інших юнітів.

Ще бувають: `.automount` , `.swap` , `.scope` , `.snapshot` та інші.

### Структура _systemd_

#### Основні функції

1. Запуск системи — ініціалізує та моніторує файлові системи, рапаралелює запуск служб (демонів), оптимізує час завантаження системи;

1. Головний процес — замінює старий init, створює адміністративний рівень між ядром і користувацьким простором, контролює вхід до системи;

1. Контроль процесів — відстежує стан системи, надає управління подіями, підтримує моніторинг та відновлення служб у випадку їх збоїв;

1. Управління службами — контроль залежностей, запуск, зупинка, перезапуск, увімкнення та вимкнення служб (команда systemctl);

1. Управління мережею — підтримка мережевих інтерфейсів і активація служб за сокетами, оптимізує використання ресурсів системи;

1. Журналювання подій — підтримує запис подій, помилок, попереджень та іншу інформацію в журнали (команда journalctl);

1. Керування контейнерами — забезпечує ізольоване оточення для контейнерів (файловий простір і мережа).

Для вирішення такого широкого спектра завдань потрібен комплексний набір програмних компонентів. Залежно від версії до набору _systemd_ входить кілька десятків виконуваних файлів і скриптів.

    Критика: Те, що колись оброблялося окремими інструментами, у _systemd_ стало «all-in-one solution», це викликало невдоволення прихильників філософії «one tool, one job» (один інструмент — одне завдання).

![Архітектура _systemd_](images/systemd_arch.png)

#### Головні компоненти

1. `systemd` — головний демон _systemd_, є першим процесом, запускається після завантаження ядра:

    - ініціалізує інші компоненти systemd

    - виконує монітування файлових систем

    - координує процес завантаження служб

1. `systemd-udevd` — служба управління пристроями:

    - виявляє та налаштовує пристрої під час роботи системи

    - гаряче підключення та вимкнення пристроїв

    - управління драйверами

    - управління правами доступу до пристроїв

1. `systemd-logind` — служба управління сеансами та пристроями користувача:

    - обробка сеансів входу в систему

    - контроль прав доступу до пристроїв і

    - обробка консолей введення-виведення

1. `systemd-journald` — служба журналювання:

    - збір, зберігання та аналіз журналів системи

    - замінює класичні текстові файли журналів

1. `systemd-networkd` — служба управління мережею:

    - налаштування та обслуговування мережевих інтерфейсів і сокетів

    - підтримка маршрутизації та інших мережевих функцій

1. `systemd-resolved` — служба управління системою імен:

    - налаштування та резолв мережевих імен

    - локальний кеш DNS

1. `systemd-timesyncd` — служба часу:

    - синхронізація системного часу за допомогою NTP (Network Time Protocol)

#### Додаткові компоненти

1. `systemd-sysctl` — компонент управління параметрами ядра і системи через файли конфігурації sysctl.

1. `systemd-analyze` — інструмент командного рядка, який надає аналіз продуктивності завантаження системи, дозволяючи оптимізувати час завантаження.

1. `systemd-rescue` — автономний цільовий компонент:

    - мінімальне оточення для налагодження та відновлення системи

    - являє собою (target) для відновлення системи. Він надає в разі проблем.

Це тільки частина компонентів _systemd_, є ще безліч інших компонентів і функцій, які сприяють ефективному управлінню системою, включно з управлінням контейнерами, плануванням завдань, моніторингом та іншим.

#### Процес запуску

Проект _systemd_ пропонує свій власний завантажувач `systemd-boot` (раніше відомий як _gummiboot_). Це простий завантажувач для систем з UEFI, він може спростити управління завантаженням і скоротити час завантаження. Однак більшість диструтивів за замовчуванням використовують просунутий Grub.

Незалежно від обраного завантажувача, його основне завдання — завантажити ядро і передати йому управління. Ядро ініціалізує залізо, налаштовує драйвери пристроїв і створює кореневу файлову систему. Після цього управління передається _systemd_ (`/lib/systemd/systemd`), яка є першим процесом (`PID=1`), що запускається в користувацькому просторі.

![Процес запуску _systemd_](images/systemd_start.png)

Ініціалізація _systemd_:

1. Завантажує базові компоненти системи та визначає _target_ (цільовий рівень завантаження)

1. Відповідно до _target_, завантажуються й активуються необхідні служби та юніти. При цьому виконується монтування файлових систем,
запуск мережевих інтерфейсів, запуск системних служб (демонів) та інших компонентів системи.

1. Після успішної активації всіх необхідних юнітів і служб створюються й активуються користувацькі інтерфейси (консоль та графіка).

#### Конфігураційні каталоги

В _systemd_ используюются специальные каталоги для размещения файлов конфигураций для юнитов. Эти каталоги предназначены для расширения и переопределения конфигураций по умолчанию, предоставляемых самим systemd. Структура:

_systemd_ використовує спеціальні каталоги для розміщення файлів конфігурації для юнітів. Ці каталоги розроблені для розширення та перевизначення конфігурацій за замовчуванням, наданих самою _systemd_. Структура:

- `/etc/systemd/system/` — (system) базові системні та створені адміністратором

- `/run/systemd/system/` — (run-time) тимчасові динамічно змінювані для системних юнітів

- `/lib/systemd/system/` — (packages) створюються з встановлених пакетів

- `/usr/lib/systemd/system/` — (read-only) базові, що постачаються із системою або пакетами

#### Сумісність з _SysVinit_

Для забезпечення сумісності з іншими скриптами ініціалізації в каталозі `/etc/init.d` передбачено спеціальний режим "System V Compatibility Mode". Але його використання не рекомендовано для інфраструктурних рішень.

## Адміністрування _systemd_

### Команда systemctl

Синтаксис: systemctl [OPTIONS] COMMAND [UNIT]

Без опцій і підкоманд відображає список усіх зареєстрованих юнітів.

Розшифровка полів:

```
UNIT — ім'я юніта
LOAD — інформує про успішне завантаження конфігурації
ACTIVE — чи активний юніт
SUB — більш детальна системна інформація про юніт
DESCRIPTION — короткий опис
```
#### Перегляд довідки

```
systemctl - -help — інтегровані команди
```
```
systemctl help — документація щодо юніту
```
Синтаксис: systemctl help PATTERN|PID

#### Перегляд інформації

```
systemctl list-units — списки юнітів
```
Синтаксис: systemctl list-units [OPTIONS] [PATTERN]

```
systemctl list-unit-files — встановлені модульні файли
```
Синтаксис: systemctl list-unit-files [PATTERN]

```
systemctl show — перевірка властивостей модуля
```
Синтаксис: systemctl show [PATTERN|JOB]

```
# Дивимося всі `units`, навіть не завантажені через помилки
systemctl list-units - -all
```
```
# Відобразити тільки активні служби
systemctl list-units - -type = service - -state = running
```
```
# Відобразити тільки неактивні `units`
systemctl list-units - -all --state = inactive
```
```
# Відобразити юніти, які не запустилися
systemctl list-units - -state = failed
```
```
# Повний список
systemctl list-unit-files
```
```
# Вибіркові звіти
systemctl list-unit-files ssh.service
systemctl list-unit-files * user *
```
```
# Перегляд усіх опцій
systemctl show ssh.service
```
```
# Вибірково відобразити одну властивість
systemctl show ssh.service - p ExecMainStartTimestamp
```

```
systemctl list-dependencies — залежності
```
Синтаксис: systemctl list-dependencies [UNIT]

#### Перевірки статусу

```
systemctl status — розширений статус виконання
```
Синтаксис: systemctl status [PATTERN|PID]

```
systemctl is-enabled / is-active / is-failed — прапор статусу
```
Синтаксис: systemctl is-active / is-failed / is-enabled [UNIT]

#### Керування статусами сервісів

Синтаксис: systemctl start / stop / restart [SERVICE]

```
systemctl start — запуск
```
```
systemctl stop — зупинка
systemctl restart — перезапуск
```
#### Керування автозапуском

Синтаксис: systemctl enable / disable [SERVICE]

```
systemctl enable — увімкнути автозапуск
systemctl disable — вимкнути автозапуск
```
### Працюємо з "Service Unit"

Для вивчення команд і принципів управління будемо використовувати NGINX.

#### Загальна структура

```
systemctl cat — перегляд конфігурації
```
Синтаксис: systemctl cat UNIT|PATTERN

Розберемо всі опції конфігураційного файла:

```
# Відобразити залежності зазначеного юніта
systemctl list-dependencies ssh.service
systemctl list-dependencies multi-user.target
systemctl list-dependencies rescue.target
```
```
# Выполняется с помощью опции is-active
systemctl status ssh.service
```
```
# Статус сервісу, зручно використовувати в скриптах
systemctl is-active ssh.service; echo $?
systemctl is-failed rescue.target; echo $?
systemctl is-enabled nginx.service; echo $?
```
```
# Якщо потрібно актуалізуємо репозиторії
sudo apt update && sudo apt upgrade - y
# Встановимо `NGINX`
sudo apt install nginx - y
```
```
# Переглянути структуру
systemctl cat nginx.service
```
```
# /lib/systemd/system/nginx.service
# =======================
# nginx signals reference doc:
# http://nginx.org/en/docs/control.html
#
```

#### Редагування юнітів

Для редагування юнітів необхідно використовувати команду systemctl edit, безпосередньо файли юнітів редагувати не рекомендується.

Зміна системного редактора за замовчуванням

```
systemctl edit — редагування конфігурації
```
Синтаксис: systemctl edit UNIT|PATTERN

Додамо опції автоматичного перезапуску:

Повідомляємо systemd про зміну конфігурації.

```
systemctl daemon-reload — перечитати конфігурацію менеджера
```
#### Тестування змін

Моделюємо ситуацію збою:

```
[ Unit] # - - Метадані служби та її взаємодія з іншими службами
Description = A high performance web server and a reverse proxy server
Documentation = man:nginx ( 8 ) # - - сторінка man, де описано роботу зі службою
After = network.target # - - умови активації служби, у даному випадку після підняття мережевих інтерфейсів
```
```
[ Service] # - - Конфігурація служби
Type = forking # - - Режим запуску
# forking — після запуску демон відгалужується (fork), завершуючи батьківський процес
# simple — під час запуску, демон переходить у режим очікування
# one-shot — разове запуск, наприклад скрипт одноразового виконання
PIDFile = /run/nginx.pid # - - файл з актуальним PID-ом служби
ExecStartPre = /usr/sbin/nginx - t -q -g 'daemon on; master_process on;' # - - команда передзапуску
ExecStart = /usr/sbin/nginx - g 'daemon on; master_process on;' # - - команда основного запуску
ExecReload = /usr/sbin/nginx - g 'daemon on; master_process on;' -s reload # - - команда перезапуску
ExecStop = - /sbin/start-stop-daemon - -quiet --stop --retry QUIT/ 5 - -pidfile /run/nginx.pid # - - команда перезапуск
TimeoutStopSec = 5 # - - таймаут очікування зупинки перед примусовим завершенням
KillMode = mixed # - - Режим завершення
# control-group — надсилає сигнали завершення всім процесам `cgroup` спільної з юнітом
# process — надсилає сигнал завершення тільки головному процесу, пов'язаному з юнітом
# mixed — спочатку як `control-group`, якщо не вдалося зупинити всі процеси, то як `proce
```
```
[ Install] # - - Налаштування автозапуску юніта
WantedBy = multi-user.target # — цільовий режим (target unit) активації активації юніта
```
```
Потрібні підвищені привілеї root
```
```
# Обираємо більш звичний редактор `vim.basic`
sudo update-alternatives - -config editor
```
```
# Відкриваємо `nginx` для редагування
sudo systemctl edit - -full nginx.service
```
```
[ Service]
...
Restart = on-failure
RestartSec = 30 s
```
```
# Актуалізуємо менеджер конфігурацій
sudo systemctl daemon-reload
```
```
# Жорстко вбиваємо процес сервісу
sudo kill - 9 $(cat /run/nginx.pid)
```
```
# Перевіримо статус
systemctl status nginx.service
# Чекаємо 60 секунд, і перевіряємо знову — він повинен бути знову запущений
```

#### Створюємо сервіс

Вставимо код:

#### Перевіряємо сервіс

### Працюємо з "Timer Unit"

Під час встановлення ОС можуть бути створені деякі таймери обслуговування системи, наприклад:

```
оновлення системних баз даних;
актуалізації програмних компонент;
очищення тимчасових директорій;
ротації лог-файлів та інше.
```
```
systemctl list-timers — розклад активних таймерів
```
Список единиц таймера, находящихся в памяти в данный момент, упорядоченный по следующему истечению времени Синтаксис:
systemctl list-timers PATTERN

#### Створюємо таймер

Важливо: Ім'я таймера має збігатися з ім'ям служби, яку він буде активувати.

```
На практиці може знадобитися під час встановлення ПЗ, наприклад, трекінг системи YouTrack
```
```
# Створимо тестовий юніт test.service
sudo vim /etc/systemd/system/test.service
```
```
[ Unit]
Description = Test-Service
```
```
[ Service]
ExecStart = /bin/echo "Hello World!"
```
```
# Актуалізуємо менеджер конфігурацій
sudo systemctl daemon-reload
# Запустимо наш тестовий сервіс
sudo systemctl start test.service
```
```
# Дивимося на статус сервісу та логи
systemctl status test.service
```
```
# Якщо знадобиться редагування
sudo systemctl edit - -full test.service
```
```
Таймер — це спеціальний тригер, що дає змогу запустити потрібні сервіси за розкладом або після настання будь-якої події. На відміну
від cron, таймер не містить команд, а лише керує сервісом, який виконує необхідну дію.
```
```
# Відобразити всі активні таймери
systemctl list-timers
```
```
# Фільтрувати за маскою імені
systemctl list-timers apt *
```
```
# Дивимося статус усіх або потрібного таймера
systemctl status * .timer
```
```
# Перевіряємо раніше створений сервіс
systemctl cat test.service
```
```
# Создадим новый unit-файл
sudo vim /etc/systemd/system/test.timer
```

Використовуємо шаблон:

Пояснення опцій:

```
AccuracySec= 1 us — вказуємо точність спрацьовування таймера, 1 мікросекунда
Persistent=true — якщо систему вимкнули в запланований час, завдання буде запущено під час наступного ввімкнення.
OnCalendar=*:*: 0 / 15 — коли виконувати, кожні 15 секунд
```
#### Перевіряємо таймер

Для моніторингу логів зручно відкрити додаткову консоль або сеанс screen.

Повертаємося в основну консоль або сеанс.

Додаткові команди

```
[ Unit]
Description = Runung Test-Service every 15 seconds
```
```
[ Timer]
AccuracySec = 1 us
Persistent = true
OnCalendar =* : * : 0 / 15
```
```
[ Install]
WantedBy = timers.target
```
```
# Перевіряємо коректність значення `OnCalendar`
systemd-analyze calendar * : * : 0 / 15
# > щопівтори хвилини
systemd-analyze calendar * : 0 / 1 , 2 / 1
# > щохвилини
systemd-analyze calendar * - * - * * : * : 00
# > щоденного о 2 : 00
systemd-analyze calendar * - * - * 02 : 00 : 00
# > щонеділі о 3 : 00
systemd-analyze calendar Sun * - * - * 03 : 00 : 00
# > кожен 10 - й день місяця
systemd-analyze calendar * - 1 / 1 - 10 00 : 00 : 00
```
```
# Контролюємо логи в окремому сеансі
journalctl - f -u test. *
```
```
# Актуалізуємо менеджер конфігурацій
sudo systemctl daemon-reload
```
```
# Перевіряємо статуси сервісу і таймера
systemctl status test.service; systemctl status test.timer
```
```
# Активуємо і запускаємо таймер
sudo systemctl enable test.timer; sudo systemctl start test.timer
```
```
# Виконуємо перезавантаження VM, і перевіряємо ще раз
sudo systemctl reboot
```
```
# Якщо знадобиться редагування
sudo systemctl edit - -full test.timer
sudo systemctl daemon-reload; sudo systemctl restart test.timer
```
```
# Зупиняємо і дезактивуємо таймер
sudo systemctl stop test.timer; sudo systemctl disable test.timer
```

## Аналіз і моніторинг

### Статистика завантаження

#### Утиліта systemd-analyze

Синтаксис: `systemd-analyze [OPTIONS] COMMAND Без опцій і підкоманд відображає статистику завантаження системи.

```
systemd-analyze blame — статистика по кожному юніту
systemd-analyze critical-chain — дерево за часом завантаження
systemd-analyze calendar — перевірка значення OnCalendar для таймера
```
### Активність сервісів

```
systemd-cgtop — інтерактивна статистика
```
### Перегляд журналів

#### Утиліта journalctl

Загальносистемні

Фільтрація за часом та датою

Фільтрація через **grep**

Фільтрація за юнітами

```
# Перевіряємо коли наступного разу буде запущено таймер
systemd-analyze calendar weekly
# Також можна `daily`, `hourly`, `monthly`
```
```
# Логи всіх завантажень
journalctl
```
```
# Список останніх завантажень
journalctl - -list-boots
```
```
# Перегляд логів завантаження за номером або хеш-ID
journalctl - b - 1
journalctl - b c 8 db 57 fa 17614054 b 4 defdf 5 fcc 084 c 2
```
```
# Тільки логи ядра
journalctl - k
journalctl - k -b - 2
```
```
# Переглянути останні 10 записів
journalctl - n 10
```
```
# У реальному часі
journalctl - f
```
```
journalctl - -since " 2023 - 03 - 21 19 : 25 : 00 "
journalctl - -since yesterday
journalctl - -since 10 : 00 - -until " 1 hour ago" -u nginx.service
```
```
journalctl - b -u ssh.service - -grep Accepted
```
```
# Подивитися всі логи завантаження певної служби
journalctl - u nginx.service
```
```
# Подивитися логи завантаження певної служби в поточному завантаженні
journalctl - b -u nginx.service
```

Фільтрація за процесами, користувачами та групами

Фільтрація за рівнем помилок

Додаткові можливості

#### Утиліта lnav

Logfile Navigator — інтерактивна утиліта навігації, фільтрації, пошуку та аналізу журналів подій. Зручна та інтуїтивно зрозуміла альтернатива
cat та grep.

# Додаткові матеріали

## Англомовні онлайн статті

```
DigitalOcean: How To Use Systemctl to Manage Systemd Services and Units
```
```
journalctl _PID = 381
journalctl - F _UID
journalctl _UID = 1000
journalctl _UID = $(id -u itadmin)
journalctl - F _GUID
journalctl _GUID = 1000
```
```
# Відобразимо всі повідомлення WARNING за ідентифікатором " 4 "
journalctl - p 4 - b
# 0 :emergency — непрацездатність системи
# 1 :alerts — попередження, що вимагають негайного втручання
# 2 :critical — критичний стан
# 3 :errors — помилки
# 4 :warning — попередження
# 5 :notice — повідомлення
# 6 :info — інформаційні повідомлення
# 7 :debug — налагоджувальні повідомлення
```
```
# Виведення без обробника сторінок
journalctl - -no-pager
```
```
# Наприклад зручно використовувати з `lnav`
journalctl - b -u ssh.service - -no-pager | lnav
```
```
# Детальніше
man systemd.journal-fields
```
