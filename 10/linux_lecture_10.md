## Розділ 10: Мережева взаємодія

### Архітектура мереж у Linux

Мережева підтримка в Linux — це набір програмних компонентів та інструментів, вбудованих в операційну систему GNU/Linux, які забезпечують функціональність мережевих з'єднань, конфігурацію мережевого інтерфейсу, маршрутизацію, мережеву безпеку та інші мережеві операції.

#### Базові поняття

##### Програми та мережі

Мережева система Linux реалізована у вигляді трьох рівнів абстракції:

![Network-Abstraction](images/11-1_Network-Abstraction.png "Network-Abstraction")

1. **[Socket Abstraction Layer](https://www.rt-thread.io/document/site/programming-manual/sal/sal/)** — сокетний програмний інтерфейс (Socket API), надає абстракцію для створення, надсилання та приймання мережевих пакетів через мережеві протоколи, як-от TCP і UDP. Він реалізований через системні виклики, такі як `socket()`, `bind()`, `listen()`, `accept()`, `connect()`, `send()`, `recv()` та інші. Реалізовується в просторі користувача (**User Space**).

2. **[Protocol Abstraction Layer](https://bjc.edc.org/Aug2016/bjc-r/cur/programming/4-internet/4-protocols/3-internet-abstraction-hierarchy.html)** — драйвери мережевих протоколів (Network Protocol Drivers) надають функціональність для оброблення пакетів і взаємодії з мережевими стеками. Вони відповідають за створення, аналіз і обробку мережевих пакетів на різних рівнях протокольного стека, таких як IP, TCP, UDP та інші. Також вони можуть забезпечувати функції, як-от фрагментація і збірка пакетів, контроль потоку, виявлення помилок та інші аспекти протоколів. У Linux драйвери протоколів включені в ядро операційної системи (**Kernel Space**).

3. **[NDD/PHY Abstraction Layer](https://docs.kernel.org/networking/phy.html)** — драйвери мережевих пристроїв (Network Device Drivers) забезпечують взаємодію між операційною системою та фізичними мережевими пристроями, такими як мережеві карти Ethernet, Wi-Fi тощо. Вони забезпечують функціональність для надсилання та приймання мережевих пакетів через мережеві інтерфейси, налаштування параметрів мережевих пристроїв, оброблення переривань та інші операції, пов'язані з пристроями. Драйвери мережевих пристроїв надають абстракцію для операційної системи, щоб вона могла взаємодіяти з різними типами мережевих адаптерів і використовувати їх для мережевої комунікації. У Linux драйвери мережевих пристроїв можуть бути вбудованими в ядро або завантажуваними модулями ядра (**Kernel Space**).

![Network-Optimization](images/11-2_Network-Optimization.png "Network-Optimization")

Для системного адміністратора і DevOps інженера глибинне розуміння даних абстракцій дає змогу ефективніше і якісніше розв'язувати задачі, пов'язані як із проєктуванням, так і з обслуговуванням інформаційних рішень. Зокрема розуміння стеків і конвеєрів обробки даних, допомагає створювати більш прості та швидкі системні рішення.

##### Стандарти та протоколи

Для мережевої взаємодії дуже важлива сумісність й надійність. Зокрема вони вирішують такі важливі завдання:

1. **Встановлення спільної мови** — визначають єдину мову і набір правил, які дають змогу різним пристроям і системам у мережі спілкуватися і взаємодіяти один з одним. Забезпечують узгодженість між різними вузлами мережі, незалежно від їхнього виробника або реалізації.

2. **Забезпечення сумісності** — гарантують можливість взаємодіяти між собою для систем, пристроїв і платформ, створених різними розробниками та виробниками. Це дає змогу будувати гетерогенні мережі, де компоненти від різних постачальників можуть без проблем працювати разом.

3. **Гарантія надійності та безпеки** — регламентують механізми та процедури для забезпечення надійності та безпеки в мережі. Визначають правила і протоколи для виявлення і виправлення помилок, управління потоком даних, контролю доступу та шифрування інформації. Це допомагає захистити мережу від загроз і забезпечити надійність передавання даних.

Мережеві стандарти та протоколи мають вирішальне значення для забезпечення сумісності в комп'ютерних мережах.

- **Апаратні стандарти** — визначають вимоги та специфікації для фізичної реалізації мережевих пристроїв і компонентів. Вони регламентують характеристики апаратури, зокрема фізичний інтерфейс, передачу даних, електричні та механічні параметри.

- **Мережеві протоколи** — визначають формати, структури та правила для обміну даними між пристроями та системами в мережі. Вони встановлюють правила для пакування, надсилання, маршрутизації та доставки даних. Протоколи визначають, як дані упаковуються в пакети, яким чином передаються мережею, як обробляються помилки і як взаємодіють різні пристрої.

Організації, що регламентують мережеві стандарти і протоколи:

1. [Institute of Electrical and Electronics Engineers (IEEE)](https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers) — Інститут інженерів з електротехніки та електроніки, міжнародна організація інженерів, що розробляє і стандартизує технології, мережевого і телекомунікаційного обладнання, комп'ютерної апаратури та електроніки.

2. [International Organization for Standardization (ISO)](https://en.wikipedia.org/wiki/International_Organization_for_Standardization) — Міжнародна організація зі стандартизації, що займається розробленням і затвердженням стандартів міжнародного рівня в різних галузях, включно з інформаційними технологіями та мережевою апаратурою.

3. [Internet Engineering Task Force (IETF)](https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force) — Робоча група з інтернет-інженерії, відкрите міжнародне співтовариство проектувальників, учених, мережевих операторів і провайдерів, яки займаються розробкою та стандартизацією протоколів Інтернету. Зокрема вони визначають стандарти протоколів IP (Internet Protocol), TCP (Transmission Control Protocol), HTTP (Hypertext Transfer Protocol) та інших, які є основою функціонування Інтернету.

4. [International Telecommunication Union (ITU)](https://en.wikipedia.org/wiki/International_Telecommunication_Union) — Міжнародна спілка електрозв'язку, займається стандартизацією телекомунікаційного обладнання, розподілом радіочастот, організацією радіозв'язку та організацією міжнародної телефонної.

5. [Ethernet Alliance](https://en.wikipedia.org/wiki/Ethernet_Alliance) — організація, що займається стандартизацією і просуванням технології Ethernet. Вони визначають стандарти для Ethernet-мереж, включно зі швидкостями передавання даних, типами кабелів та іншими аспектами.

##### OSI та TCP/IP

Для систематизації знань і принципів, що описуються мережевими стандартами і протоколами, існує дві суміжні концепції — модель OSI і стек протоколів TCP/IP.

![Model-OSI](images/11-3_OSI-TCPIP.png "Model-OSI")

- **[Модель OSI](https://en.wikipedia.org/wiki/OSI_model)** (Open Systems Interconnection) — концептуальна модель, запропонована Міжнародною організацією зі стандартизації (ISO). Вона складається з 7 рівнів абстракції, кожен з яких представляє певний функціональний аспект взаємодії комп'ютерних систем у мережі.

- **[Стек протоколів TCP/IP](https://en.wikipedia.org/wiki/Internet_protocol_suite)** — структуризація протоколів, що використовуються в Інтернет і комп'ютерних мережах, заснованих на протоколах IP (Internet Protocol), ARP (Address Resolution Protocol), ICMP (Internet Control Message Protocol), TCP (Transmission Control Protocol), UDP (User Datagram Protocol) та інших.

![OSI-TCP/IP](images/11-4_OSI-TCPIP.png "OSI-TCP/IP")

**Порівняння OSI та TCP/IP:** Модель OSI надає більш загальну і детальну структуру, розділяючи функціональність на різні рівні. Стек протоколів TCP/IP можна розглядати як практичну реалізацію моделі OSI. При цьому функції протоколів стека TCP/IP можуть відповідати одному або декільком рівням моделі OSI

#### Фізичні та віртуальні інтерфейси

Ядро Linux надає широку підтримку різних мережевих Ethernet та Wi-Fi адаптерів, модемів і шлюзів для мобільних мереж 3G-5G й багато іншого. Поряд з ними підтримуються різні віртуальні інтерфейси, включно з VLAN (Virtual LAN), VPN і TAP-інтерфейси та віртуальні пристрої, наприклад, Ethernet мости (bridges) і комутатори (switches). Така підтримка реалізується через драйвери мережевих пристроїв.

> **Драйвери мережевих пристроїв** — це програмні модулі рівня ядра, що забезпечують взаємозв'язок між фізичними або віртуальними інтерфейсами і рівнем мережевих протоколів.

До завдань драйверів мережевих пристроїв також входить налаштування і керування параметрами обладнання, наприклад налаштування режиму зв'язку і швидкості обміну даними.

##### Утиліти для Ethernet-адаптерів

**`ethtool`** — (Ethernet Tools) відображення та зміни налаштувань Ethernet адаптерів

Дає інформацію про стан і налаштування мережевого інтерфейсу, зокрема, швидкість з'єднання, дуплексний режим, MAC-адресу, статистику передавання та інші.

```bash
# Переглянути інформацію про мережевий інтерфейс
ethtool <interface>

# Параметри драйвера адаптера
ethtool -i <interface>

# Статистика обміну даними
ethtool -S <interface>

# Зміна швидкості та дуплексного режиму
ethtool -s <interface> speed 100 duplex full

# Відключити автовизначення режимів зв'язку
ethtool -s <interface> autoneg off
```

##### Сучасні утиліти для Wi-Fi

Ці утиліти надають сучасніші та гнучкіші методи керування бездротовими мережевими інтерфейсами та мережами Wi-Fi, а також замінюють попередні утиліти `iwconfig`, `iwlist`, `iwpriv`.

**`iw`** — більш сучасна утиліта для роботи з бездротовими мережами

Дає змогу виконувати широкий спектр операцій, включно з керуванням станціями, налаштуванням параметрів, скануванням мереж, аналізом і моніторингом бездротової активності.

**`wpa_supplicant`** — управління Wi-Fi-з'єднаннями з підтримкою WPA/WPA2-шифрування

Дозволяє сканувати доступні бездротові мережі та отримувати інформацію про їх параметри та сигнал. Підтримує налаштування та управління різними методами аутентифікації, включаючи WPA-PSK, WPA-EAP та інші.

##### Застарілі утиліти, пакет `wireless-tools`

Надає утиліти для налаштування бездротових мережевих інтерфейсів і супроводу бездротових мереж Wi-Fi.

**`iwconfig`** — перегляд та налаштування параметрів бездротових мережевих інтерфейсів

Встановлення ESSID (імені мережі), частоти, потужності передавача, режиму роботи та інших параметрів.

**`iwgetid`** — інформації про поточний підключений бездротовий мережевий інтерфейс бездротової мережі

Вона повертає інформацію про ідентифікатор мережі (ESSID) і MAC-адресу бездротового інтерфейсу.

**`iwlist`** — інформація про доступні бездротові мережі в околиці

Дає змогу сканувати бездротові мережі, виводити список виявлених мереж та їхніх атрибутів, як-от ESSID, частота, рівень сигналу та шифрування.

**`iwpriv`** — доступ до нестандартних функцій бездротових пристроїв

Керування опціями специфічними для певних апаратних засобів або драйверів.

**`iwspy`** — аналізу якості з'єднання з бездротовою мережею

Збір статистики сигналів і рівнів шуму від бездротових мереж у радіодіапазоні.

#### Мережеві протоколи та інтерфейси

Ядро Linux містить TCP/IP-стек, який відповідає за обробку мережевих протоколів на рівні Інтернету (IPv4/IPv6). Це реалізовується через мережеві інтерфейси, які також називають протокольними інтерфейсами.

> **Мережевий (протокольний) інтерфейс** — це відображення фізичного або віртуального інтерфейсу на рівні мережевих протоколів, яке дає змогу призначати мережеві адреси (IPv4/IPv6) і забезпечує можливість маршрутизації.

Стек TCP/IP підтримує різні мережеві протоколи, такі як TCP (Transmission Control Protocol), UDP (User Datagram Protocol), IPsec (Internet Protocol Security), DNS (Domain Name System). А також обслуговується службовими протоколами, зокрема ARP (Address Resolution Protocol), ICMP (Internet Control Message Protocol), IGMP (Internet Group Management Protocol) та іншими.

Деякі функції протоколів TCP/IP-стеку:

- Конфігурація мережевих інтерфейсів — налаштування IP-адрес і мережевих масок, встановлення MTU (Maximum Transmission Unit) та інших параметрів;

- Службові мережеві сервіси — автоматизація адміністративних операцій призначення IP-адрес (DHCP), обслуговування мережевих імен (DNS), мережеві файлові сисеми (NFS, Samba) і багато іншого;

- Маршрутизація та трансляція портів — переспрямування мережевого трафіку між різними мережевими інтерфейсами та мережами, прокидання портів (port forwarding);

- Динамічна маршрутизація — підтримка протоколів маршрутизації, таких як RIP (Routing Information Protocol), OSPF (Open Shortest Path First), BGP (Border Gateway Protocol) та інших;

- Файєрволи та безпека мережі — контроль доступу до мережевих ресурсів і політики безпеки, фільтрацію пакетів на рівні ядра ("Netfilter") та захист від атак;

- Моніторинг і налагодження мережі — допомагає адміністраторам аналізувати мережевий трафік, перевіряти доступність мережевих вузлів і виявляти можливі проблеми мережі.

Поряд із підтримкою Інтернет-протоколів, в Linux також є підтримка протоколів **[AppleTalk](https://en.wikipedia.org/wiki/AppleTalk)** і **[Novell IPX](https://en.wikipedia.org/wiki/Internetwork_Packet_Exchange)**, але їх застосування вже не має великої популярності.

##### Системна інформація

Інформція щодо стану і статистики роботи протоколів і мережевих інтерфейсів доступна через файли у віртуальній файловій системі `/proc`.

- Мережеві інтерфейси

```bash
# Дізнатися назви інтерфейсів
ls /sys/class/net
# або
ll /sys/class/net

# Статистика мережевих інтерфейсів: дані про передавання та приймання пакетів, помилки та інші метрики
cat /proc/net/dev

# Кеш ARP (Address Resolution Protocol): відповідність IP-адрес і MAC-адрес
cat /proc/net/arp

# Список IPv6-адрес, пов'язаних із кожним мережевим інтерфейсом
cat /proc/net/if_inet6

# Дані, необхідні для snmp агента: статистика IP, ICMP, TCP та UDP
cat /proc/net/snmp
```

- Маршрутизація

```bash
# Таблиці маршрутизації IPv4 та IPv6 відповідно
cat /proc/net/route
cat /proc/net/ipv6_route
```

- Мережеві протоколи

```bash
# Відобразити список активних протоколів
cat /proc/net/protocols

# Параметри і статистика IPv4
ll /proc/sys/net/ipv4/

# Параметри і статистика IPv6
ll /proc/sys/net/ipv6/
```

- Протоколи TCP/UDP

```bash
# Список TCP-з'єднань IPv4 та IPv6 відповідно
cat /proc/net/tcp
cat /proc/net/tcp6

# Список UDP-з'єднань IPv4 та IPv6 відповідно
cat /proc/net/udp
cat /proc/net/udp6
```

Для управління опціями системних налаштувань краще використовувати спеціальну системну функцію `sysctl`.

**`sysctl`** — перегляд та налаштування параметрів ядра під час роботи системи

Наприклад, якщо не використовуємо IPv6, то для оптимізації системи можемо його відключити:

```bash
# Перевіряємо поточний статус
sysctl net.ipv6.conf.all.disable_ipv6

# Відключаємо IPv6 на поточному сеансі
sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1

# Додаємо опцію у файлі конфігурації ядра
sudo echo 'net.ipv6.conf.all.disable_ipv6 = 1' >> /etc/sysctl.conf
# або відкриваємо в редакторі та змінюємо потрібний рядок
sudo vim /etc/sysctl.conf

# Застосувати зміни з файлу `/etc/sysctl.conf`.
sudo sysctl -p
```

##### Пакет утиліт `iproute2`

Надає гнучкі та потужні засоби для роботи з мережевими протоколами. Сучасна та рекомендована заміна застарілого пакета `net-tools`.

**`ip`** — основна утиліта для роботи з TCP/IP протоколами

Дає змогу керувати IP-адресацією, маршрутизацією, інтерфейсами, тунелями та іншими аспектами мережевої конфігурації.

- Перегляд інформації про мережеві інтерфейси

```bash
# Загальна інформація про мережеві інтерфейси
ip addr show

# Лише IPv4 адреси з масками мереж
ip -4 addr | awk '/inet/ {print $2}'

# Перегляд статусу інтерфейсу
ip link show <interface>

# Дізнатися MAC-адресу мережевого інтерфейсу
ip link show <interface> | awk '/ether/ {print $2}'
```

- Керування мережевими інтерфейсами

```bash
# Встановлення IP-адреси та маски підмережі
ip addr add <ip_address>/<subnet_mask> dev <interface>

# Встановлення шлюзу за замовчуванням
ip route add default via <gateway_address>

# Увімкнення або вимкнення інтерфейсу
ip link set <interface> up/down
```

- Маршрутизація

```bash
# Перегляд таблиці маршрутизації
ip route show

# Додавання маршруту
ip route add <destination_network> via <gateway_address> dev <interface>

# Видалення маршруту
ip route del <destination_network>
```

- Керування ARP

```bash
# Перегляд таблиці ARP
ip neigh show

# Очищення таблиці ARP
sudo ip neigh flush all

# Додавання статичного запису в таблицю ARP
sudo ip neigh add <ip_address> lladdr <mac_address> dev <interface>

# Видалення запису з таблиці ARP
sudo ip neigh del <ip_address> dev <interface>

# Пошук MAC-адреси за IP-адресою
ip neigh show to <ip_address> dev <interface>
```

- Керування мостами

```bash
# Створення мосту
ip link add name <bridge_name> type bridge

# Додавання інтерфейсів у міст
ip link set <interface> master <bridge_name>
```

- Керування VLAN

```bash
# Створення VLAN-інтерфейсу
ip link add link <parent_interface> name <vlan_interface> type vlan id <vlan_id>
```

- Тунелювання

```bash
# Створення тунелю
ip tunnel add <tunnel_name> mode <tunnel_mode> remote <remote_address> local <local_address>

# Встановлення параметрів тунелю
ip tunnel change <tunnel_name> <parameter_name> <parameter_value>
```

**`ss`** — управління мережевими з'єднаннями та сокетами

- Перегляд станів сокетів та з'єднань

```bash
# Усі сокети й з'єднаня
ss | less

# Перегляд зведеної статистики
ss -s

# Активні UCP з'єднання
ss -u

# UCP сокети та активні з'єднання
ss -ua

# TCP активні з'єднання (ESTABLISHED) для IPv4
ss -4t

# TCP порти в очікуванні підключення (LISTEN)
ss -tl

# Усі IPv4 сокети і з'єднання без резолву імені сервісу
ss -4an

# Виконати DNS-резолв для всіх IP-адрес
ss -tr

# Розширена інформація по сокетах про таймери та пам'ять
ss -treoim
```

- Фільтрація за адресами, портами та станами

```bash
# Показати всі з'єднання із заданої адреси на локальний порт вказаного сервісу
ss dst 192.168.1.1 sport ssh

# TCP з'єднання відібраних за номером порту
ss -tan '( sport = :22 or dport = :22 )'

# TCP з'єднання в зазначеному стані
ss -t state established
```

- Керування процесами (потребує root-привілеїв)

```bash
# Показати PID для TCP з'єднань на вказаний порт
sudo ss -ptn sport 22

# Видалити процеси для з'єднань відібраних за умовами
sudo ss --kill dst 192.168.1.1 sport 22
```

**`tc`** — управління мережевим трафіком і QoS (Quality of Service)

**`bridge`** — управління мережевими мостами (bridges)

**`ipset`** — управління списками IP-адрес для фільтрації пакетів

##### Пакет утиліт `net-tools`

Містить базові інструменти керування TCP/IP протоколами, які широко використовувалися в минулому. Зараз вважається застарілим і замінюється більш сучасним `iproute2`.

**`ifconfig`** — налаштування параметрів мережевих інтерфейсів

Встановлення IP-адрес, масок підмережі, налаштування MTU та інших опцій.

**`netstat`** — перегляду мережевих з'єднань, портів і таблиці маршрутизації

**`route`** — управління таблицями маршрутизації

**`arp`** — управління таблицями ARP

#### API та BSD-сокети

На цьому рівні ядро Linux надає програмний інтерфейс (API) для користувацьких додатків і сервісів. Цей API заснований на BSD-сокетах (Berkeley Software Distribution Sockets).

![Network-Functions](images/11-5_Network-Functions.png "Network-Functions")

**[BSD Sockets](https://en.wikipedia.org/wiki/Berkeley_sockets)** — абстракція, що дає змогу програмістам створювати клієнтські та серверні додатки, використовуючи системні функції та виклики (API). Найбільш часто використовувані функції для створення, налаштування та управління TCP/UDP сокетами: `socket()`, `bind()`, `listen()`, `accept()`, `connect()`, `send()`, `recv()`, `close()` та інші.

**Сокет** — це кінцева точка двостороннього каналу обміну даними між двома процесами, що реалізується кодом ядра. При цьому взаємодіючі процеси можуть перебувати на різних комп'ютерах.

#### Система доменних імен — DNS

Для спрощення використання Інтернет, замість запам'ятовування числових IP-адрес користувачам пропонується більш зручна для взаємодії, система доменних імен. У системах Linux функції DNS (Domain Name System), виконує `systemd-resolved`, що є компонентом "_systemd_". Він замінює старіші інструменти та компоненти, такі як `resolv.conf`, `nsswitch.conf`, `gethostbyname` та інші.

##### **`resolvectl`** — перегляд і управління функціями системи DNS

Є частиною пакета `systemd-resolved`.

- Налаштування та статистика:

```bash
# Показати поточні налаштування
resolvectl status

# Звіт за запитами кешу
resolvectl statistics

# Перегляд вмісту DNS-кеша
sudo killall -USR1 systemd-resolved && journalctl -u systemd-resolved | grep -A 100000 "CACHE:"

# Обнулити статистику resolver
reset-statistics

# Очистити всі локальні кеші DNS
flush-caches
```

- Резолв імен:

```bash
# Резолв імені в IP-адресу
resolvectl query {{domain1 domain2 ...}}
resolvectl query i.ua google.com

# Резолв IP-адреси в ім'я
resolvectl query {{ip_address}}
resolvectl query 8.8.8.8
```

#### Системний та мережевий час

Системний час — це час, який ОС відображає в цей момент і міститься в мітках часу журналів, часу створення, зміни та відкриття файлів тощо.

Підтримка годинника реального часу реалізована на двох рівнях:

- **Апаратний годинник** — (RTC) працює безперервно і забезпечує автономний відлік часу, навіть коли апаратна система знеструмлена, використовується окремий акумулятор або літієва батарея.

Оскільки апаратні годинники не підтримують концепцію часових поясів, то вона реалізується програмними засобами операційних систем.

- **Системний час** — існує тільки під час роботи операційної системи, виставляється за апаратним годинником, але з урахуванням різниці часового поясу налаштованого в системі.

##### Перевірка часу

Обслуговування системного часу і його синхронізацію, в дистрибутивах з підсистемою "systemd", забезпечує сервіс `timesyncd` і команда `timedatectl`.

```bash
# Відобразити значення апаратного годинника реального часу
sudo hwclock

# Переглянути системний час
date

# Відобразити загальну інформацію
timedatectl
```

##### Зміна часового поясу

```bash
# Вибираємо відповідний часовий пояс у потрібному регіоні
timedatectl list-timezones | grep Europe | column

# Встановити необхідне нове значення
sudo timedatectl set-timezone Europe/Zaporozhye
```

##### Синхронізація часу

Точний час і дата — дуже важливі аспекти коректної роботи багатьох сучасних сервісів, також це негативно позначається на логуванні під час пошуку помилок у журналі + правильний час гарантує запуск завдань `cron` і `systemd` у потрібний час і дату.

Для синхронізації часу зі стандартним еталонним годинником через інтернет використовують [Network Time Protocol (NTP)](https://en.wikipedia.org/wiki/Network_Time_Protocol) — Мережевий протокол часу.

```bash
systemctl status systemd-timesyncd.service

# Перевірка статусу синхронізації з NTP серверами
timedatectl timesync-status

# Змінити пул NTP серверів конфігураційний файл `systemd-timesyncd`
sudo vim /etc/systemd/timesyncd.conf
```

---

#### Керування налаштуваннями мережі

У сучасних версіях Ubuntu для керування налаштуваннями мережі використовується утиліта "Netplan", також її може бути встановлено і на інші дистрибутиви (наприклад Debian). Це дає змогу уніфікувати процес налаштування, через опис конфігурації мережі в єдиному YAML-файлі, розташованому в каталозі `/etc/netplan`.

> **YAML** (YAML Ain't Markup Language) - мова розмітки, що використовується для структурованого подання даних у конфігураційних файлах. У її основі простий і зрозумілий текстовий синтаксис, структурований відступами.

![Netplan_Logo](images/11-6-Netplan_Logo.png "Netplan_Logo")

- Приклад конфігурації:

```yaml
network:
version: 2          # -- версія YAML
  renderer: networkd  # -- менеджер мережі (networkd або NetworkManager)
  ethernets:        # -- налаштування мережевих адаптерів ethernet
    eth0:           # -- налаштування для відповідних мережевих адаптерів
      dhcp4: no     # -- отримувати IP-адресу автоматично (yes/true) або вручну (no/false)
      addresses:    # -- задає IP-адреси через кому
        - 192.168.1.100/24
      gateway4:     # -- шлюз за замовчуванням
        192.168.1.1
      nameservers:  # -- налаштування DNS-серверів
        addresses: [8.8.8.8, 8.8.4.4]
```

Фактично це декларативний сценарій, за яким `netplan` генерує конфігурації для відповідного бекенда (мережевих менеджерів `NetworkManager` або`systemd-networkd`).

```bash
# Визначаємо який в системі менеджер мережі
systemctl status NetworkManager
systemctl status systemd-networkd
```

##### **`netplan`** — утиліта для налаштування мережі через `/etc/netplan/*.yaml`

Основні команди:

```bash
# Спробувати застосувати конфігурацію з можливістю скасування
netplan try

# Застосувати конфігурацію
netplan apply

# Перевірка поточної конфігурації та запис на диск
netplan generate

# Записати поточну конфігурацію мережі в YAML
netplan config
```

---

#### Підсистема Netfilter

Для забезпечення безпеки міжмережевої взаємодії в ядро Linux вбудовано підсистему контролю мережевого трафіка та опрацювання правил фільтрації пакетів.

![Netfilter_Logo](images/11-7_Netfilter_Logo.png "Netfilter_Logo")

- **[ipchains](https://en.wikipedia.org/wiki/Ipchains)** — перша система фільтрації пакетів, впроваджена в ядро Linux. Розроблена наприкінці 1990-х років Джейсоном Хейзлеттом (Jason Haaslett) і впроваджена в ядро Linux версії 2.2.0, що вийшло в січні 1999 року. Вона надавала можливість контролю вхідного і вихідного трафіку мережевого на основі фільтрації пакетів за IP-адресами і TCP/UDP портами. Використовувалася для налаштування файєрволів і забезпечення мережевої безпеки.

1. **[Netfilter](https://en.wikipedia.org/wiki/Netfilter)** — відома як ipchains-ng (ipchains-next generation), з'явилася як заміна ipchains. Її розробив Харалд Вельтен (Harald Welte) і команда розробників, і вперше її включили в ядро Linux версії 2.4.17, випущене в грудні 2001 року.

![Netfilter_Components](images/11-8_Netfilter_Components.png "Netfilter_Components")

"Netfilter" забезпечує гнучкішу й потужнішу систему контролю та фільтрації пакетів мережевого трафіку з використанням хуків, правил і модулів. Порівняно з `ipchains`, вона дає суттєві поліпшення, зокрема, більш тонке налаштування правил фільтрації, обробку пакетів на різних етапах їхнього проходження через ядро, а також включала можливості Network Address Translation (NAT) і stateful-фільтрації.

![Netfilter-Flowchart](images/11-9_Netfilter-Flowchart.png "Netfilter-Flowchart")

Підсистема Netfilter це основа для різних інструментів і програмних продуктів, як-от `iptables`, `nftables` і багатьох інших, для налаштування файєрволів і забезпечення безпеки мережі в Linux.

![iptables-Flowchart](images/11-10_iptables-Flowchart.png "iptables-Flowchart")

### Файєрволи в Linux

Файєрволи (_Firewalls_) - це важливі інструменти безпеки, які моніторять і контролюють вхідний та вихідний мережевий трафік на основі заздалегідь визначених правил безпеки. Вони діють як бар'єри між вашою мережею та потенційно шкідливими об'єктами в Інтернеті, допомагаючи запобігти несанкціонованому доступу та атакам.

У Linux існує кілька реалізацій файєрволів, включаючи:

1. **iptables**: Це потужний інструмент файєрвола, який дозволяє адміністраторам налаштовувати правила для фільтрації пакетів, мережевої адресації (NAT) та інших мережевих завдань. Він є частиною мережевого стеку ядра Linux.

   Основні команди iptables для управління файєрволом включають:

   - `iptables -A INPUT -s <source> -j DROP`: Відкидає пакети з певного джерела.
   - `iptables -A INPUT -p tcp --dport <port> -j ACCEPT`: Дозволяє вхідний TCP-трафік на певному порту.
   - `iptables -L`: Показує поточні правила iptables.

2. **ufw (Uncomplicated Firewall)**: Створений для спрощення управління файєрволом користувачам, ufw надає дружній інтерфейс користувача до iptables.

   Основні команди ufw включають:

   - `ufw allow <port>/<protocol>`: Дозволяє трафік на певному порту та протоколу.
   - `ufw deny from <ip_address>`: Блокує трафік від певної IP-адреси.
   - `ufw status`: Показує поточний статус та правила файєрволу.

3. **firewalld**: firewalld є динамічним демоном для управління файєрволом з підтримкою мережевих зон. Він надає інтерфейс командного рядка під назвою `firewall-cmd`.

   Основні команди firewall-cmd включають:

   - `firewall-cmd --zone=public --add-port=<port>/tcp --permanent`: Додає постійне правило для дозволу TCP-трафіку на певному порту.
   - `firewall-cmd --zone=public --add-source=<ip_address> --permanent`: Додає постійне правило для дозволу трафіку з певної IP-адреси.
   - `firewall-cmd --reload`: Перезавантажує конфігурацію файєрволу для застосування змін.

### Мережеві сервіси

Для виконання своєї роботи мережеві клієнти підключаються до відповідних мережевих серверів. Мережеві сервери Unix бувають різних форм. Серверна програма може слухати порт самостійно або через допоміжний сервер.

Мережеві клієнти використовують протоколи й інтерфейси транспортного рівня операційної системи, тому важливо розуміти основи транспортних рівнів TCP і UDP.

#### Основні мережеві сервіси

Запити TCP є одними з найлегших для розуміння, оскільки вони побудовані на простих безперервних двосторонніх потоках даних. Можливо, найкращий спосіб побачити, як вони працюють, — зв’язатися безпосередньо з незашифрованим веб-сервером на TCP-порту 80, щоб отримати уявлення про те, як дані переміщуються через з’єднання. Наприклад, виконайте таку команду, щоб підключитися до прикладу веб-сервера:

```bash
telnet httpbin.org 80
```

Ви повинні отримати таку відповідь, яка вказує на успішне підключення до сервера:

```bash
Trying some address...
Connected to httpbin.org.
Escape character is '^]'.
```

Тепер введіть ці два рядки:

```bash
GET / HTTP/1.1
Host: httpbin.org
```

Натисніть ENTER двічі після останнього рядка. Сервер має надіслати у відповідь купу тексту HTML. Щоб завершити підключення, натисніть `CTRL-D`.
Ця вправа демонструє, що:

- Віддалений хост має процес веб-сервера, який прослуховує TCP-порт 80.
- `telnet` був клієнтом, який ініціював підключення.

Причина, по якій вам потрібно розірвати з’єднання за допомогою `CTRL-D`, полягає в тому, що оскільки для завантаження більшості веб-сторінок потрібно кілька запитів, має сенс залишати з’єднання відкритим. Якщо ви досліджуєте веб-сервери на рівні протоколу, ви можете виявити, що така поведінка різниться. Наприклад, багато серверів швидко відключаються, якщо вони не отримують запит одразу після відкриття з’єднання.

**ПРИМІТКА**: `telnet` спочатку мав на меті дозволити вхід на віддалені хости. Хоча сервер віддаленого входу telnet абсолютно небезпечний, клієнт `telnet` може бути корисним для налагодження віддалених служб. `telnet` не працює з UDP або будь-яким транспортним рівнем, крім TCP.

#### HTTP запит з консолі

Хоча ви зазвичай використовуєте веб-браузер для встановлення такого роду з’єднання, давайте зробимо лише один крок вище від `telnet` і скористаємося програмою командного рядка, яка знає, як спілкуватися з прикладним рівнем HTTP:

```bash
curl --trace-ascii trace_file http://www.example.org/
```

Ви отримаєте багато результатів HTML. Проігноруйте його (або перенаправте до `/dev/null`) і натомість перегляньте щойно створений файл `trace_file`:

```bash
== Info: Trying 93.184.216.34...
== Info: TCP_NODELAY set
== Info: Connected to www.example.org (93.184.216.34) port 80
(#0)
```

_Усе, що ви бачили досі, відбувається на транспортному рівні або нижче._

Однак, якщо це з’єднання вдається, `curl` намагається надіслати запит (`header`); тут починається прикладний рівень:

```plaintext
1 => Send header, 79 bytes (0x4f)
2 0000: GET / HTTP/1.1
0010: Host: www.example.org
0027: User-Agent: curl/7.58.0
0040: Accept: */*
004d:
--snip--
<= Recv header, 17 bytes (0x11)
0000: HTTP/1.1 200 OK
<= Recv header, 22 bytes (0x16)
0000: Accept-Ranges: bytes
<= Recv header, 12 bytes (0xc)
0000: Age: 17629
--snip--
```

Заголовок у відповіді сервера може бути досить довгим, але в якийсь момент сервер переходить від передачі заголовків до надсилання фактично запитаного документа:

```plaintext
<= Recv header, 22 bytes (0x16)
0000: Content-Length: 1256
<= Recv header, 2 bytes (0x2)
1 0000:
<= Recv data, 1256 bytes (0x4e8)
0000: <!doctype html>.<html>.<head>. <title>Example Domain</title>. 0040: . <meta charset="utf-8" />. <meta httpequiv="Content-type
--snip--
```

Незважаючи на те, що вихідні дані налагодження містять заголовок `Recv` і дані `Recv`, що означає, що це два різних типи повідомлень від сервера, немає різниці в тому

- як `curl` спілкувався з операційною системою, щоб отримати два повідомлення
- як операційна система їх обробляла
- як мережа обробляла пакети під ними.

Різниця полягає виключно в програмі `curl` у просторі користувача.

#### Мережеві сервери

Більшість мережевих серверів схожі на інші серверні демони у вашій системі, такі як `cron`, за винятком того, що вони взаємодіють із мережевими портами. Ось деякі інші поширені мережеві сервери, які можуть бути запущені у вашій системі:

- `httpd`, `apache`, `apache2`, `nginx`: веб-сервери
- `sshd`: демон безпечної оболонки
- `postfix`, `qmail`, `sendmail`: поштові сервери
- `cupsd`: сервер друку
- `nfsd`, `mountd`: Демони мережевої файлової системи (спільного використання файлів).
- `smbd`, `nmbd`: демони обміну файлами Windows
- `rpcbind`: демон служби карти портів віддаленого виклику процедури (`RPC`).

Спільною особливістю більшості мережевих серверів є те, що вони зазвичай працюють як кілька процесів.

Принаймні один процес прослуховує мережевий порт, і після отримання нового вхідного з’єднання процес прослуховування використовує `fork()` для створення дочірнього процесу, який потім відповідає за нове з’єднання.

Дочірній процес, який часто називають робочим процесом, завершується, коли з’єднання закривається. Тим часом вихідний процес прослуховування продовжує прослуховувати мережевий порт.

Цей процес дозволяє серверу легко обробляти багато з’єднань без особливих проблем.

### SSH — протокол захищеного керування

![SSH_Logo](images/11-12_SSH_Logo.png "SSH_Logo")

Для захищеного віддаленого адміністрування та обміну системними даними одним із найпопулярніших є протокол SSH.

> **SSH** (Secure Shell) — протокол захищеного віддаленого керування та безпечного передавання даних між двома системами через незахищену мережу, таку як Інтернет. Він забезпечує шифрування даних і аутентифікацію користувача та забезпечує захищене з'єднання для тунелювання TCP-з'єднань.

Протокол SSH працює в концепції клієнт-серверної архітектури. Сервери приймають вхідні з'єднання на 22-му порту TCP і аутентифікують клієнтів. Весь трафік між клієнтом і сервером, включно з автентифікацією та обміном даними, зашифрований. Для шифрування поетапно використовуються різні криптографічні алгоритми, які автоматично узгоджуються відповідно до налаштувань клієнта і сервера, а також типу ключів.

#### Основні сфери застосування

1. Віддалене адміністрування — керування системами через шел, моніторинг і діагностика;
2. інформаційний обмін — захищене передавання файлів і конфіденційних даних;
3. тунелювання портів — підтримка захищених каналів для передавання трафіку через незахищену мережу.

Також SSH використовується для безпечної автентифікації та передачі даних під час роботи з системами контролю версій (Git).

#### Принципи та алгоритми шифрування

Завдання безпечної передачі даних вирішуються за допомогою двох основних типів криптографічних алгоритмів. У протоколі SSH застосовуються як симетричне, так і асиметричне шифрування. Також чималу роль відіграють алгоритми стиснення та функції хешування.

##### Симетричне шифрування

![SSH_Key-01](images/11-13_SSH_Key-01.png "SSH_Key-01")

У цьому сімействі алгоритмів для шифрування і дешифрування використовується один загальний ключ/секрет "shared secret". Це означає, що будь-хто, хто отримає ключ, зможе читати і надсилати повідомлення іншим власникам того ж ключа.
Підходить для передачі великих обсягів зашифрованих даних:

- забезпечує високу швидкість шифрування / дешифрування
- не вимогливий до продуктивності CPU
- може працювати в потоці

Але має недоліки:

- потрібна конфідиціальність передання ключів "з рук у руки"
- труднощі використання з необмеженою кількістю учасників (серверів)

У SSH застосовується для шифрування встановленого з'єднання, водночас використовуються сеансові ключі, які обираються тільки на один сеанс. Обмін сеансовими ключами захищається асиметричним шифруванням.

##### Асиметричне шифрування

![SSH_Key-02](images/11-13_SSH_Key-02.png "SSH_Key-02")
На відміну від симетричного шифрування для передавання даних в одному напрямку потрібні два пов'язані один з одним ключі. Один із них відомий як приватний (`private key`), інший називається публічним (`public key`).

- **Private key** — секретний / конфідиціальний ключ, ніколи і за жодних обставин його не можна передавати третім особам або публікувати деінде.

- **Public key** — публічний / вільно переданий ключ, хоч він і пов'язаний із секретним ключем, але цей зв'язок необоротний, тобто відтворити один ключ з іншого не можливо.

Асимітричне шифрування дає змогу зашифровувати дані одним ключем, а розшифрувати тільки його парним/відповідним ключем.В

В протоколі SSH асиметричне шифрування використовується в процесі обміну сеансовими ключами, а також може брати участь в процедурі аутентифікації.

##### Функції хешування

У протоколі SSH застосовується для перевірки автентичності "відбитка пальця" (fingerprint) віддаленого сервера, це дає змогу захиститися від атак класу "Людина по середині" (_Man-in-the-Middle_).

#### Робота з клієнтом openSSH

OpenSSH є одним з найпопулярніших наборів програмного забезпечення для безпечного з'єднання з віддаленими комп'ютерами через мережу. Він включає в себе інструменти для створення захищених з'єднань, таких як SSH-сервер та SSH-клієнт. Дозволяє здійснювати безпечний доступ до віддаленого комп'ютера або сервера, а також виконувати команди та передавати файли через захищене з'єднання. Основні аспекти роботи з клієнтом OpenSSH на Linux:

1. **Встановлення клієнта OpenSSH**: Більшість сучасних дистрибутивів Linux поставляються з встановленою програмою клієнта OpenSSH за замовчуванням. Якщо вона не встановлена, ви можете встановити її за допомогою менеджера пакунків вашого дистрибутиву.

2. **З'єднання з віддаленим сервером**: Для з'єднання з віддаленим сервером використовуйте команду `ssh`. Синтаксис команди: `ssh [користувач]@[адреса_сервера]`. Наприклад, `ssh user@example.com`.

3. **Автентифікація**: Під час першого з'єднання з сервером, клієнт SSH може попросити вас підтвердити ідентифікатор сервера. Це може бути зроблено за допомогою підпису (підтвердження за допомогою ключа), або введенням пароля.

4. **Керування ключами SSH**: SSH використовує пари ключів для аутентифікації користувачів. Ключі можуть бути генеровані за допомогою команди `ssh-keygen`. Публічний ключ потім може бути розповсюджений на сервер, а приватний ключ залишається на локальній машині.

5. **Виконання команд на віддаленому сервері**: Після з'єднання з сервером ви можете виконувати команди, додавши їх до команди `ssh`. Наприклад, `ssh user@example.com ls -l` виконає команду `ls -l` на віддаленому сервері.

6. **Передача файлів**: Для передачі файлів між локальною машиною та віддаленим сервером використовуйте команду `scp`. Наприклад, `scp file.txt user@example.com:/remote/directory` передасть файл `file.txt` на віддалений сервер.

7. **Закриття з'єднання**: Після завершення роботи на віддаленому сервері використовуйте команду `exit` для закриття сеансу SSH і повернення до вашої локальної машини.

OpenSSH є потужним і надійним інструментом для взаємодії з віддаленими серверами через мережу, і він широко використовується у сфері адміністрування систем Linux.

#### Налаштування SSH-сервера

Налаштування SSH сервера на Linux включає в себе кілька кроків, які дозволять вам безпечно з'єднатися з сервером за допомогою протоколу SSH. Ось деякі основні кроки для налаштування SSH сервера на Linux:

1. **Перевірте встановлення пакету OpenSSH-Server**: Перш за все, переконайтеся, що на вашому сервері встановлено програмне забезпечення SSH сервера. Ви можете встановити його за допомогою менеджера пакунків вашого дистрибутиву Linux. Наприклад, для Ubuntu і Debian використовуйте команду `sudo apt-get install openssh-server`.

2. **Змініть налаштування SSH сервера (необов'язково)**: Налаштування SSH сервера зазвичай зберігаються в файлі `/etc/ssh/sshd_config`. У цьому файлі ви можете вказати різні параметри, такі як порт, на якому слухати сервер, дозволені методи аутентифікації, обмеження на підключення та інші параметри. Після внесення змін у файл налаштувань необхідно перезапустити службу SSH за допомогою команди `sudo systemctl restart sshd`.

3. **Додайте правила файрволу (за необхідності)**: Якщо на вашому сервері встановлено файрвол, вам може знадобитися додати правила для дозволу вхідних підключень на порт, на якому працює SSH сервер (зазвичай порт 22).

   Наприклад, для утиліти `iptables` команда може виглядати так:

   ```bash
   # у випадку використання iptables все доволі просто
   sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
   ```

   або для `firewalld`:

   ```bash
   # визначаємо зону для відкриття порту
   sudo firewall-cmd --get-active-zones

   # додаємо порт 22 в зону public
   sudo firewall-cmd --zone=public --add-port=22/tcp --permanent

   # перезавантажуємо файєрвол
   sudo firewall-cmd --reload
   ```

4. **Перевірте доступ користувачів**: Переконайтеся, що користувачі, з яких ви хочете дозволити вхід на сервер, мають власні облікові записи на сервері.

5. **Тестування підключення**: Після налаштування SSH сервера ви можете спробувати підключитися до нього з іншого комп'ютера за допомогою клієнта SSH. Використовуйте команду `ssh user@server_ip` для підключення, де `user` - це користувач на сервері, а `server_ip` - IP-адреса або ім'я хоста вашого сервера.

6. **Забезпечте безпеку**: Важливо забезпечити безпеку SSH сервера. Використовуйте ключі SSH для аутентифікації замість паролів, встановлюйте доступ до SSH тільки з внутрішньої мережі або використовуйте VPN, включайте фільтрацію IP-адрес в файрволі і т.д.

Загалом, налаштування SSH сервера на Linux нескладне, але вимагає уваги до безпеки та правильної конфігурації для запобігання можливих атак.

#### Створення SSH-ключів для сервера

При запуску сервера вперше, він може не мати ключів SSH, які використовуються для шифрування з'єднань SSH. Це може призвести до помилки "sshd: no hostkeys available -- exiting".

Щоб виправити цю помилку, вам потрібно згенерувати ключі хоста для вашого SSH сервера. Ви можете це зробити за допомогою утиліти `ssh-keygen`.

1. Запустіть команду для генерації ключів хоста. Вона може виглядати так:

   ```bash
   ssh-keygen -A
   ```

   Ця команда перегенерує всі ключі хоста для вашого SSH сервера.

1. Далі треба додати новостворені ключі до конфігурації SSH сервера. Для цього відкрийте файл `/etc/ssh/sshd_config` у текстовому редакторі і додайте або розкоментуйте наступні рядки:

   ```bash
   HostKey /etc/ssh/ssh_host_rsa_key
   HostKey /etc/ssh/ssh_host_ecdsa_key
   HostKey /etc/ssh/ssh_host_ed25519_key
   ```

   Ці ключи будуть використовуватися для шифрування з'єднань SSH на вашому сервері.

1. Перезапустіть службу SSH:

   ```bash
   systemctl restart sshd
   ```

##### Авторизація SSH за ключами

`ssh-keygen` — генерація асимітричних ключів

```bash
# Створення нової пари ключів, приватний ключ можна закрити паролем
ssh-keygen -t ed25519 -f ~/.ssh/mykey_ed25519 -C "username@hostname"

# Перевірка результату
ll ./.ssh

# Відобразити публічний ключ
cat ~/.ssh/mykey_ed25519.pub
```

`ssh-add` — керування ssh-агентом

```bash
# Активувати ssh-агента
eval ssh-agent
eval $(ssh-agent -s)

# Додавання приватного ключа в ssh-agent
ssh-add ~/.ssh/mykey_ed25519

# Перевірка ключів доступних у ssh-agent
ssh-add -l

# За необхідності видалити всі
ssh-add -D
```

#### Авторизація за допомогою ключів

Ви можете використовувати ключі SSH для автентифікації замість паролів. Це забезпечує більшу безпеку і зручність при роботі з віддаленими серверами.

Налаштувати автентифікацію за ключами SSH можна зі сторони як клієнта, так і сервера.

Зі сторони клієнта:

1. Створіть ключі SSH на своєму локальному комп'ютері за допомогою команди `ssh-keygen`.

2. Запустіть команду `ssh-copy-id user@server`, щоб скопіювати ваш публічний ключ на віддалений сервер.

Зі сторони сервера:

1. Додайте ваш публічний ключ до файлу `~/.ssh/authorized_keys` на сервері.

Передавати публічні ключі загалом безпечно, оскільки вони не містять конфіденційної інформації. Приватні ключі повинні залишатися конфіденційними і ніколи не передаватися третім особам.

### Налагодження мережевих сервісів

Утиліти налагодження мережі в Linux дозволяють аналізувати та відлагоджувати мережевий трафік, перевіряти стан мережевих з'єднань та виконувати інші дії для діагностики мережі.

1. **netstat** - використовується для перегляду стану мережевих з'єднань, маршрутизації та інших мережевих параметрів. Наприклад, команда `netstat -r` показує таблицю маршрутизації.

   - Перегляд відкритих мережевих портів: `netstat -tuln`
   - Відображення мережевих з'єднань із PID процесу: `netstat -p`
   - Перегляд стану мережевих інтерфейсів: `netstat -i`

2. **lsof** - відображає відкриті файли та сокети. Для перегляду відкритих мережевих з'єднань можна використати команду `lsof -i`.

   - Відображення відкритих файлів та сокетів для конкретного процесу: `lsof -p <PID>`
   - Перегляд відкритих сокетів для конкретного користувача: `lsof -u <username>`

3. **tcpdump** - це мережевий аналізатор, який дозволяє перехоплювати і аналізувати мережевий трафік. Наприклад, `tcpdump -i eth0` перехоплює трафік на інтерфейсі eth0.

   - Перехоплення пакетів на певному порті: `tcpdump -i <interface> port <port>`
   - Збереження перехоплених пакетів у файл: `tcpdump -i <interface> -w <file>`

4. **netcat** - це утиліта для зчитування та запису даних з/на мережеві сокети. Вона може бути використана для створення серверів та клієнтів TCP/UDP. Наприклад, `nc -l -p 1234` створює TCP-сервер, який слухає на порту 1234.

   - Відправлення даних на вказаний порт: `echo "Hello" | nc <host> <port>`
   - Прослуховування вхідних з'єднань на порту: `nc -l -p <port>`

5. **nmap** - це сканер мережі, який використовується для виявлення активних хостів на мережі та визначення відкритих портів на цих хостах. Наприклад, `nmap -sP 192.168.1.0/24` сканує підмережу 192.168.1.0/24 для виявлення активних хостів.

   - Сканування відкритих портів на хості: `nmap <host>`
   - Виявлення оперативної системи на хості: `nmap -O <host>`

## Nginx

Nginx (вимовляється як "engine-x") - це вебсервер та проксі-сервер з відкритим вихідним кодом, який вперше був випущений у 2004 році. Він став популярним завдяки своїй високій продуктивності, надійності, простоті налаштування та низькому споживанню ресурсів.

![nginx](images/nginx.png)

### Основна інформація

- **Висока продуктивність**: Nginx володіє великим потенціалом для обробки великого обсягу запитів, що робить його ідеальним для високонавантажених вебсайтів та додатків.
- **Проксі та балансування навантаження**: Nginx може використовуватися як проксі-сервер для перенаправлення запитів на різні сервери та для балансування навантаження між ними.
- **Підтримка статичного та динамічного контенту**: Він добре працює зі статичними та динамічними вебсайтами, включаючи вебсайти на основі PHP, Python, Ruby та інших мов програмування.
- **Простота налаштування**: Конфігурація Nginx здебільшого здійснюється за допомогою конфігураційних файлів, що є зрозумілими та легкими для використання.

### Альтернативи

Хоча Nginx є дуже популярним вебсервером, існують і інші альтернативи, такі як:

- **Apache HTTP Server**: Це один з найпоширеніших вебсерверів у світі, відомий своєю гнучкістю та великою кількістю модулів.
- **Microsoft IIS**: інформаційний сервер від Microsoft, який використовується для хостингу вебсайтів на платформі Windows.

### Переваги Nginx

- **Висока продуктивність та масштабованість**: Nginx ефективно працює з великим обсягом запитів, дозволяючи підтримувати високу доступність вебсайтів та додатків.
- **Простота налаштування**: Конфігурація Nginx здебільшого здійснюється за допомогою зрозумілих конфігураційних файлів, що робить його легким у використанні.
- **Надійність**: Nginx відомий своєю стабільністю та надійністю, що робить його відмінним вибором для критичних застосунків.
- **Багатофункціональність**: Nginx підтримує різноманітні функції, включаючи кешування, проксі-сервери, балансування навантаження та багато іншого.

Nginx є потужним та надійним вебсервером та проксі-сервером, який використовується для обробки великого обсягу запитів. Він володіє високою продуктивністю, простотою налаштування та надійністю, що робить його популярним вибором серед веброзробників.

Для створення вебсервера на Nginx на Linux потрібно встановити та налаштувати Nginx, а потім додати власний HTML-код для відображення на вебсторінці. Ось кроки:

## Робота з Nginx

### Встановлення Nginx

Встановіть Nginx з репозиторію вашого дистрибутиву Linux. Наприклад, для Ubuntu використовуйте:

```bash
sudo apt update
sudo apt install nginx
```

### Запуск та перевірка статусу

Після встановлення запустіть Nginx та перевірте його статус:

```bash
sudo systemctl start nginx
sudo systemctl status nginx
```

### Налаштування фаєрволу (опціонально)

Якщо у вас увімкнено фаєрвол, дозвольте доступ до порту 80 (стандартний порт HTTP) для вебтрафіку:

```bash
sudo ufw allow 'Nginx HTTP'
```

### Додавання свого HTML-коду

Створіть або скопіюйте свій HTML-код у каталог, який буде відповідати за статичний контент Nginx (зазвичай це `/var/www/html/` на більшості дистрибутивів):

```bash
sudo nano /var/www/html/index.html
```

Вставте свій HTML-код у файл `index.html`.

### Налаштування віртуального хосту (опціонально)

Якщо вам потрібно налаштувати віртуальний хост, створіть конфігураційний файл для нього у каталозі `/etc/nginx/sites-available/`. Наприклад:

```bash
sudo nano /etc/nginx/sites-available/example.com
```

```nginx
server {
    listen 80;
    server_name example.com;

    location / {
        root /var/www/html;
        index index.html;
    }
}
```

Активуйте цей файл, створивши символьне посилання у каталозі `sites-enabled`:

```bash
sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/
```

### Перезавантаження та перевірка

Перезавантажте Nginx, щоб застосувати зміни та перевірте роботу вашого вебсервера в браузері, перейшовши за адресою вашого сервера (або домену, якщо ви використовуєте віртуальний хост).

```bash
sudo systemctl reload nginx
```

## Віртуальні хости

Віртуальні хости (Virtual Hosts) дозволяють одному вебсерверу обслуговувати кілька доменних імен або сайтів на одному IP-адресі.

Вони є корисними для розділення вебсайтів та додавання додаткової функціональності до вашого вебсервера.

У Nginx віртуальні хости налаштовуються за допомогою конфігураційних файлів, які вказуються у директиві `server`.

### Базовий синтаксис віртуального хоста у Nginx

```nginx
server {
    listen 80;  # Порт, на якому прослуховується віртуальний хост
    server_name example.com;  # Доменне ім'я або IP-адреса віртуального хоста

    location / {
        # Налаштування для обробки запитів
    }

    # Додаткові налаштування можна додавати тут
}
```

## Додаткові налаштування віртуального хоста

1. **Коренева директорія**: Вказується за допомогою директиви `root` і вказує шлях до директорії, де знаходяться файли вебсайту.

   ```nginx
   root /var/www/example.com;
   ```

2. **Індексні файли**: Дозволяє вказати список індексних файлів, які будуть автоматично знайдені та відображені при відсутності конкретного файлу у запиті.

   ```nginx
   index index.html index.htm index.php;
   ```

3. **Проксі**: Nginx може бути сконфігурований як проксі-сервер для пересилання запитів на інший сервер. Це корисно для розподілення навантаження або забезпечення безпеки.

   ```nginx
   location / {
       proxy_pass http://localhost:8000;
       proxy_set_header Host $host;
       proxy_set_header X-Real-IP $remote_addr;
   }
   ```

4. **SSL/TLS**: Для налаштування HTTPS можна використовувати сертифікати SSL/TLS. Налаштування охоплюють шлях до сертифікатів та параметри безпеки.

   ```nginx
   listen 443 ssl;
   ssl_certificate /path/to/fullchain.pem;
   ssl_certificate_key /path/to/privkey.pem;
   ```

5. **Перенаправлення**: Можна налаштувати віртуальний хост для перенаправлення HTTP-запитів на іншу адресу.

   ```nginx
   location / {
       return 301 https://example.com$request_uri;
   }
   ```

6. **Основні параметри безпеки**: Додавання параметрів безпеки, таких як обмеження доступу за IP-адресою або шифрування паролів.

   ```nginx
   location / {
       allow 192.168.1.0/24;
       deny all;
       auth_basic "Restricted Content";
       auth_basic_user_file /etc/nginx/.htpasswd;
   }
   ```

Це лише декілька прикладів додаткових налаштувань, які можна використовувати у віртуальних хостах Nginx. Вони дозволяють налаштувати різні аспекти вебсервера для кращої роботи з вашими вебсайтами.
