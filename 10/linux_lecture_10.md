# Розділ 10: Запуск простору користувача

Простір користувача починається приблизно в цьому порядку:

1. Ядро запускає процес `init`

1. Запускаються основні служби низького рівня, такі як `udevd` та `syslogd`

1. Проходить конфігурація мережі

1. Запускаються служби середнього рівня та високого рівня (`cron`, `printing` тощо)

1. З'являється запрошення на вхід, GUI та інші високорівневі програми

## Вступ до `init`

Програма `init` — це програма простору користувача, як і будь-яка інша програма в системі Linux, і ви знайдете її в _/sbin_ разом з іншими системними бінарними файлами. Основна її мета - запускати та зупиняти основні службові процеси в системі.

Є три основні реалізації:

- _System V init_: традиційна `init` (RHEL та інші)

- _systemd_: новий стандарт для `init`

- _Upstart_: колишня реалізація `init` на Ubuntu (замінена на _systemd_)

### Завдання та принципи роботи

В Unix-подібних системах, існує головний системний процес, який завжди має PID=1, це система ініціалізації та управління службами.
Вона виконує певні важливі функції:

1. Завантаження системи — запуск та ініціалізацію всіх компонентів ОС (драйверів пристроїв і системних служб);

2. Управління службами — дає змогу запускати, зупиняти й перезапускати служби, і керувати їхньою конфігурацією;

3. Контроль подій і помилок — відстежує системні події та обробляє їх необхідним чином.

### Хронологія розвитку

- Спочатку 1970-х років у класичних Unix системах використовувався процес ініціалізації _init_. Це досить просте рішення засноване на Shell-скриптах та послідовній їх обробці під час завантаження системи. Вона і досі зустрічається в Unix-системах.

- У 1984 році було створено Систему _rc_ Деном Берком (Dan Berks) для "BSD 4.2" (Berkeley Software Distribution). Вона стала частиною проєкту BSD і альтернативою простої системи _init_, надалі вона увійшла у FreeBSD і його форки.

- На наприкінці 1980-х років, з'явилася _SysVinit_ (System V initialization). Як і системі _init/rc_, вона спирається на скрипти, розташовані в `/etc/rc.d/` або `/etc/rc`. У ній ввели поняття рівнів виконання runlevels, які задають стан системи та набір виконуваних служб.

- У 2006 році компанією Canonical створено _Upstart_, яка стала заміною _SysVinit_ і вперше з'явилася в Ubuntu 6.10. Вона була розроблялася з урахуванням багатопроцесорних систем і покращувала паралельний запуск служб. У ній так само впроваджено контроль подій і можливість реагувати на зміну станів системи. _Upstart_ використовує подієву модель ініціалізації, де запуск і зупинка служб засновані на подіях, а не на простому порядку запуску. Однак широкого поширення _Upstart_ так і не набув.

- У 2007 році розробник Gentoo, Рой Марплс (Roy Marples) представив світові _OpenRC_, як просту і легковажну заміну _SysVinit_. Вона дотримувалася принципів і концепцій системи ініціалізації BSD і сумісна з нею за структурою каталогів і скриптів. Зараз використовується в Gentoo та Alpine Linux.

- У 2010 році було представлено _systemd_, створену Леннартом Поттерінгом (Lennart Poettering), Кай Зіверс (Kay Siever) і колективом розробників (Red Hat). Це цілісна система ініціалізації, яка забезпечує паралельне завантаження, поліпшене логування, управління залежностями, автоматичну активацію служб під час запиту, засоби налагодження та моніторингу, а також інші додаткові функції. Стала основною для багатьох дистрибутивів Linux, зокрема Ubuntu.

## System V RunLevels

У будь-який момент часу в системі Linux виконується певний базовий набір процесів (наприклад, `crond` і `udevd`). В ініціалізації System V цей стан машини називається її рівнем запуску (_RunLevel_), який позначається числом від 0 до 6. Ви можете перевірити рівень запуску вашої системи за допомогою команди `who -r`.

## Ідентифікація `init` системи

- Якщо у вашій системі є каталоги `/usr/lib/systemd` і `/etc/systemd`, у вас _systemd_

- Якщо у вас є каталог `/etc/init`, який містить кілька файлів `.conf`, ви ймовірно використовуєте _Upstart_

- Якщо жодне з наведених вище не відповідає дійсності, але у вас є файл `/etc/inittab`, ви ймовірно використовуєте _System V init_

## systemd

Systemd — центральна система ініціалізації та управління службами. Вона обробляє все, що виходить за рамки завдань ядра із запуску та управління системою.

`systemd init` керує процесом завантаження системи та має на меті об’єднати ряд стандартних служб Unix (`cron`, `inetd`). Він також вміє відкладати запуск служб і функцій операційної системи, поки вони не знадобляться.

![systemd](./images/systemd.png)

Система ініціалізації _systemd_ використовується в CentOS-7+, Debian-8+, Ubuntu-15.04+, Fedora15+, openSUSE 12.1+.

### Переваги _systemd_

- Краща підтримка паралельного запуску служб;

- Ширший набір функцій управління та моніторингу;

- Комплексний і сучасний підхід до управління системою в цілому.

При цьому його аналоги також застосовуються в деяких інфраструктурних рішеннях, наприклад у docker-контейнерах часто використовується Alpine Linux через легший _OpenRC_.

Подібним функціональним аналогом у Windows є підсистема "Service Control Manager (SCM)" та її утиліти sc start, sc stop, sc query та інші.

## Базові поняття та терміни

Концепція _systemd_ базується на керуванні "юнітами" (unit). Через них описуються різні компоненти та стани системи, визначаються залежності та контролюється їхній запуск, зупинка і взаємодія.

    Unit — основна одиниця управління systemd. Це конфігураційний файл, що описує системний об'єкт: процес, ресурс або стан системи.

### Базові типи юнітів

`.target` — (цільовий стан) абстракція, що групує інші юніти та визначає стан системи, що виникає під час запуску або перемикання режимів.

```bash
# Перегляд усіх наявних у системі "Target Unit"
systemctl list-units --all --type=target
```

Деякі приклади:

- `multi-user.target` — "Multi-User System", визначає активність служб, необхідних для багатокористувацької роботи

- `graphical.target` — "Graphical Interface", визначає готовність графічних інтерфейсів GNOME або KDE.

- `rescue.target` — "Bootup into Rescue mode", режим відновлення, визначає мінімальний набір служб для "порятунку" системи.

`.service` — (сервіс/служба) описує системний сервіс (демон), визначає команди запуску, зупинки та перезапуску сервісу, а також задає залежності та налаштування оточення.

```bash
# Перегляд усіх наявних у системі "Service Unit"
systemctl list-units --all --type=service
```

Деякі приклади:

- `ssh.service` — "OpenBSD Secure Shell server"

- `systemd-remount-fs.service` — "Remount Root and Kernel File Systems"

- `nginx.service` — "A high performance web server and a reverse proxy server"

`.timer` — (таймер завдань), заміна й аналог `cron`, визначає час запуску та інтервали повторення для виконання інших юнітів.

```bash
# Перегляд усіх наявних у системі "Timer Unit"
systemctl list-units --all --type=timer
```

Деякі приклади:

- `apt-daily-upgrade.timer` — "Daily apt upgrade and clean activities"

- `logrotate.timer` — "Daily rotation of log files"

- `mdmonitor-oneshot.timer` — "Reminder for degraded MD arrays"

`.mount` — (ресурс, що монтується), визначає диск або мережеву директорію, тип файлової системи, точку монтування та інші параметри.

```bash
# Перегляд усіх наявних у системі "Mount Unit"
systemctl list-units --all --type=mount
```

Деякі приклади:

- `.mount` — "Root Mount"

- `proc-sys-fs-binfmt_misc.mount` — "Arbitrary Executable File Formats File System"

- `sys-kernel-config.mount` — "Kernel Configuration File System"

### Інші типи юнітів

`.socket` — (юніт сокет), визначає мережевий або UNIX-сокет, який використовується для обміну даними між процесами та юнітами.

```bash
# Перегляд усіх наявних у системі "Socket Unit"
systemctl list-sockets
```

`.path` — (юніт шляху), дає змогу відстежувати зміни у файлах або директоріях і реагувати на них, активуючи пов'язані сервіси або інші юніти.

`.slice` — (юніт зрізу), описує групу процесів або інших юнітів для застосування до них політик управління ресурсами процесора, пам'яті або введення-виведення.

`.device` — (юніт пристрою), абстракція над фізичним або віртуальним пристроєм для налаштування параметрів, права доступу та залежностей від інших юнітів.

Ще бувають: `.automount`, `.swap`, `.scope`, `.snapshot` та інші.

## Структура _systemd_

### Основні функції

1. Запуск системи — ініціалізує та моніторить файлові системи, розпаралелює запуск служб (демонів), оптимізує час завантаження системи;

1. Головний процес — замінює старий init, створює адміністративний рівень між ядром і користувацьким простором, контролює вхід до системи;

1. Контроль процесів — відстежує стан системи, надає управління подіями, підтримує моніторинг та відновлення служб у випадку їх збоїв;

1. Управління службами — контроль залежностей, запуск, зупинка, перезапуск, увімкнення та вимкнення служб (команда systemctl);

1. Управління мережею — підтримка мережевих інтерфейсів і активація служб за сокетами, оптимізує використання ресурсів системи;

1. Журналювання подій — підтримує запис подій, помилок, попереджень та іншу інформацію в журнали (команда journalctl);

1. Керування контейнерами — забезпечує ізольоване оточення для контейнерів (файловий простір і мережа).

Для вирішення такого широкого спектра завдань потрібен комплексний набір програмних компонентів. Залежно від версії до набору _systemd_ входить кілька десятків виконуваних файлів і скриптів.

    Критика: Те, що колись оброблялося окремими інструментами, у systemd стало «all-in-one solution», це викликало невдоволення прихильників філософії «one tool, one job» (один інструмент — одне завдання).

![Архітектура _systemd_](images/systemd_arch.png)

### Головні компоненти

1. `systemd` — головний демон _systemd_, є першим процесом, запускається після завантаження ядра:

   - ініціалізує інші компоненти systemd

   - виконує монтування файлових систем

   - координує процес завантаження служб

1. `systemd-udevd` — служба управління пристроями:

   - виявляє та налаштовує пристрої під час роботи системи

   - гаряче підключення та вимкнення пристроїв

   - управління драйверами

   - управління правами доступу до пристроїв

1. `systemd-logind` — служба управління сеансами та пристроями користувача:

   - обробка сеансів входу в систему

   - контроль прав доступу до пристроїв і

   - обробка консолей введення-виведення

1. `systemd-journald` — служба журналювання:

   - збір, зберігання та аналіз журналів системи

   - замінює класичні текстові файли журналів

1. `systemd-networkd` — служба управління мережею:

   - налаштування та обслуговування мережевих інтерфейсів і сокетів

   - підтримка маршрутизації та інших мережевих функцій

1. `systemd-resolved` — служба управління системою імен:

   - налаштування та резолв мережевих імен

   - локальний кеш DNS

1. `systemd-timesyncd` — служба часу:

   - синхронізація системного часу за допомогою NTP (Network Time Protocol)

### Додаткові компоненти

1. `systemd-sysctl` — компонент управління параметрами ядра і системи через файли конфігурації sysctl.

1. `systemd-analyze` — інструмент командного рядка, який надає аналіз продуктивності завантаження системи, дозволяючи оптимізувати час завантаження.

1. `systemd-rescue` — автономний цільовий компонент:

   - мінімальне оточення для налагодження та відновлення системи

   - являє собою _target_ для відновлення системи. Він надає в разі проблем.

Це тільки частина компонентів _systemd_, є ще безліч інших компонентів і функцій, які сприяють ефективному управлінню системою, включно з управлінням контейнерами, плануванням завдань, моніторингом та іншим.

### Процес запуску

Проєкт _systemd_ пропонує свій власний завантажувач `systemd-boot` (раніше відомий як _gummiboot_). Це простий завантажувач для систем з UEFI, він може спростити управління завантаженням і скоротити час завантаження. Однак більшість дистрибутивів за замовчуванням використовують _grub_.

Незалежно від обраного завантажувача, його основне завдання — завантажити ядро і передати йому управління. Ядро ініціалізує залізо, налаштовує драйвери пристроїв і створює кореневу файлову систему. Після цього управління передається _systemd_ (`/lib/systemd/systemd`), яка є першим процесом (`PID=1`), що запускається в користувацькому просторі.

![Процес запуску _systemd_](images/systemd_start.png)

Ініціалізація _systemd_:

1. Завантажує базові компоненти системи та визначає _target_ (цільовий рівень завантаження)

1. Відповідно до _target_, завантажуються й активуються необхідні служби та юніти. При цьому виконується монтування файлових систем,
   запуск мережевих інтерфейсів, запуск системних служб (демонів) та інших компонентів системи.

1. Після успішної активації всіх необхідних юнітів і служб створюються й активуються користувацькі інтерфейси (консоль та графіка).

### Конфігураційні каталоги

_systemd_ використовує спеціальні каталоги для розміщення файлів конфігурації для юнітів. Ці каталоги розроблені для розширення та перевизначення конфігурацій за замовчуванням, наданих самою _systemd_. Структура:

- `/etc/systemd/system/` — (system) базові системні та створені адміністратором

- `/run/systemd/system/` — (run-time) тимчасові динамічно змінювані для системних юнітів

- `/lib/systemd/system/` — (packages) створюються з встановлених пакетів

- `/usr/lib/systemd/system/` — (read-only) базові, що постачаються із системою або пакетами

### Сумісність з _SysVinit_

Для забезпечення сумісності з іншими скриптами ініціалізації в каталозі `/etc/init.d` передбачено спеціальний режим "System V Compatibility Mode". Але його використання не рекомендовано для інфраструктурних рішень.

## Адміністрування _systemd_

### Команда `systemctl`

Синтаксис: `systemctl [OPTIONS] COMMAND [UNIT]`

Без опцій і підкоманд відображає список усіх зареєстрованих юнітів.

Розшифровка полів:

- _UNIT_ — ім'я юніта

- _LOAD_ — інформує про успішне завантаження конфігурації

- _ACTIVE_ — чи активний юніт

- _SUB_ — більш детальна системна інформація про юніт

- _DESCRIPTION_ — короткий опис

### Перегляд довідки

```bash
systemctl - -help — інтегровані команди
```

```bash
systemctl help — документація щодо юніту
```

Синтаксис: `systemctl help PATTERN|PID`

### Перегляд інформації

- `systemctl list-units` — списки юнітів

Синтаксис: `systemctl list-units [OPTIONS] [PATTERN]`

```bash
# Дивимося всі `units`, навіть не завантажені через помилки
systemctl list-units --all

# Відобразити тільки активні служби
systemctl list-units --type=service --state=running

# Відобразити тільки неактивні `units`
systemctl list-units --all --state=inactive

# Відобразити юніти, які не запустилися
systemctl list-units --state=failed
```

- `systemctl list-unit-files` — встановлені модульні файли

Синтаксис: `systemctl list-unit-files [PATTERN]`

```bash
# Повний список
systemctl list-unit-files

# Вибіркові звіти
systemctl list-unit-files ssh.service
systemctl list-unit-files *user*
```

- `systemctl show` — перевірка властивостей модуля

Синтаксис: `systemctl show [PATTERN|JOB]`

```bash
# Перегляд усіх опцій
systemctl show ssh.service

# Вибірково відобразити одну властивість
systemctl show ssh.service -p ExecMainStartTimestamp
```

- `systemctl list-dependencies` — залежності

Синтаксис: `systemctl list-dependencies [UNIT]`

```bash
# Відобразити залежності зазначеного юніта
systemctl list-dependencies ssh.service
systemctl list-dependencies multi-user.target
systemctl list-dependencies rescue.target
```

### Перевірки статусу

- `systemctl status` — розширений статус виконання

Синтаксис: `systemctl status [PATTERN|PID]`

```bash
# Виконується за допомогою опції is-active
systemctl status ssh.service
```

- `systemctl is-enabled / is-active / is-failed` — прапор статусу

Синтаксис: `systemctl is-active / is-failed / is-enabled [UNIT]`

```bash
# Статус сервісу, зручно використовувати в скриптах
systemctl is-active ssh.service; echo $?
systemctl is-failed rescue.target; echo $?
systemctl is-enabled nginx.service; echo $?
```

### Керування статусами сервісів

Синтаксис: `systemctl start / stop / restart [SERVICE]`

- `systemctl start` — запуск

- `systemctl stop` — зупинка

- `systemctl restart` — перезапуск

### Керування автозапуском

Синтаксис: `systemctl enable / disable [SERVICE]`

- `systemctl enable` — увімкнути автозапуск

- `systemctl disable` — вимкнути автозапуск

## Працюємо з "Service Unit"

Для вивчення команд і принципів управління будемо використовувати _NGINX_.

```bash
# Якщо потрібно актуалізуємо репозиторії
sudo apt update && sudo apt upgrade -y

# Встановимо `NGINX`
sudo apt install nginx -y
```

### Загальна структура

- `systemctl cat` — перегляд конфігурації

Синтаксис: `systemctl cat UNIT|PATTERN`

Розберемо всі опції конфігураційного файлу:

```bash
# /lib/systemd/system/nginx.service
# =======================
# nginx signals reference doc:
# http://nginx.org/en/docs/control.html
#
[Unit] # — Метадані служби та її взаємодія з іншими службами
Description=A high performance web server and a reverse proxy server
Documentation=man:nginx(8) # — сторінка man, де описано роботу зі службою
After=network.target # — умови активації служби, у даному випадку після підняття мережевих інтерфейсів
[Service] # — Конфігурація служби
Type=forking # — Режим запуску
# forking — після запуску демон відгалужується (fork), завершуючи батьківський процес
# simple — під час запуску, демон переходить у режим очікування
# one-shot — разовий запуск, наприклад скрипт одноразового виконання
PIDFile=/run/nginx.pid # — файл з актуальним PID-ом служби
ExecStartPre=/usr/sbin/nginx -t -q -g 'daemon on; master_process on;' # — команда передзапуску
ExecStart=/usr/sbin/nginx -g 'daemon on; master_process on;' # — команда основного запуску
ExecReload=/usr/sbin/nginx -g 'daemon on; master_process on;' -s reload # — команда перезапуску
ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid # — команда перезапуск
TimeoutStopSec=5 # — таймаут очікування зупинки перед примусовим завершенням
KillMode=mixed # — Режим завершення
# control-group — надсилає сигнали завершення всім процесам `cgroup` спільної з юнітом
# process — надсилає сигнал завершення тільки головному процесу, пов'язаному з юнітом
# mixed — спочатку як `control-group`, якщо не вдалося зупинити всі процеси, то як `process`
[Install] # — Налаштування автозапуску юніта
WantedBy=multi-user.target # — цільовий режим (target unit) активації активації юніта
```

### Редагування юнітів

Для редагування юнітів необхідно використовувати команду `systemctl edit`, безпосередньо файли юнітів редагувати не рекомендується.

    Потрібні підвищені привілеї root

Зміна системного редактора за замовчуванням

```bash
# Обираємо більш звичний редактор `vim.basic`
sudo update-alternatives --config editor
```

- `systemctl edit` — редагування конфігурації

Синтаксис: `systemctl edit UNIT|PATTERN`

```bash
# Відкриваємо `nginx` для редагування
sudo systemctl edit --full nginx.service
```

Додамо опції автоматичного перезапуску:

```bash
[Service]
...
Restart=on-failure
RestartSec=30s
```

Повідомляємо `systemd` про зміну конфігурації.

- `systemctl daemon-reload` — перечитати конфігурацію менеджера

```bash
# Актуалізуємо менеджер конфігурацій
sudo systemctl daemon-reload
```

### Тестування змін

Моделюємо ситуацію збою:

```bash
# Жорстко вбиваємо процес сервісу
sudo kill -9 $(cat /run/nginx.pid)

# Перевіримо статус
systemctl status nginx.service
# Чекаємо 60 секунд, і перевіряємо знову — він повинен бути знову запущений
```

### Створюємо сервіс

```bash
# Створимо тестовий юніт test.service
sudo vim /etc/systemd/system/test.service
```

Вставимо код:

```bash
[Unit]
Description=Test-Service
[Service]
ExecStart=/bin/echo "Hello World!"
```

### Перевіряємо сервіс

```bash
# Актуалізуємо менеджер конфігурацій
sudo systemctl daemon-reload

# Запустимо наш тестовий сервіс
sudo systemctl start test.service

# Дивимося на статус сервісу та логи
systemctl status test.service

# Якщо знадобиться редагування
sudo systemctl edit --full test.service
```

## Працюємо з "Timer Unit"

Під час встановлення ОС можуть бути створені деякі таймери обслуговування системи, наприклад:

- оновлення системних баз даних;

- актуалізації програмних компонент;

- очищення тимчасових директорій;

- ротації лог-файлів та інше.

  Таймер — це спеціальний тригер, що дає змогу запустити потрібні сервіси за розкладом або після настання будь-якої події. На відміну від `cron`, таймер не містить команд, а лише керує сервісом, який виконує необхідну дію.

- `systemctl list-timers` — розклад активних таймерів

Синтаксис: `systemctl list-timers PATTERN`

```bash
# Відобразити всі активні таймери
systemctl list-timers

# Фільтрувати за маскою імені
systemctl list-timers apt*

# Дивимося статус усіх або потрібного таймера
systemctl status *.timer
```

### Створюємо таймер

_Важливо_: Ім'я таймера має збігатися з ім'ям служби, яку він буде активувати.

```bash
# Перевіряємо раніше створений сервіс
systemctl cat test.service

# Створимо новий unit-файл
sudo vim /etc/systemd/system/test.timer
```

Використовуємо шаблон:

```bash
[Unit]
Description=Running Test-Service every 15 seconds

[Timer]
AccuracySec=1us
Persistent=true
OnCalendar=*:*:0/15

[Install]
WantedBy=timers.target
```

Пояснення опцій:

- `AccuracySec=1us` — вказуємо точність спрацьовування таймера, 1 мікросекунда

- `Persistent=true` — якщо систему вимкнули в запланований час, завдання буде запущено під час наступного ввімкнення.

- `OnCalendar=*:*:0/15` — коли виконувати, кожні 15 секунд

```bash
# Перевіряємо коректність значення `OnCalendar`
systemd-analyze calendar *:*:0/15

# > щопівтори хвилини
systemd-analyze calendar *:0/1,2/1

# > щохвилини
systemd-analyze calendar *-*-* *:*:00

# > щоденного о 2:00
systemd-analyze calendar *-*-* 02:00:00

# > щонеділі о 3:00
systemd-analyze calendar Sun *-*-* 03:00:00

# > кожен 10-й день місяця
systemd-analyze calendar *-1/1-10 00:00:00
```

### Перевіряємо таймер

Для моніторингу логів зручно відкрити додаткову консоль або сеанс `screen`.

```bash
# Контролюємо логи в окремому сеансі
journalctl -f -u test.*
```

Повертаємося в основну консоль або сеанс.

```bash
# Актуалізуємо менеджер конфігурацій
sudo systemctl daemon-reload

# Перевіряємо статуси сервісу і таймера
systemctl status test.service; systemctl status test.timer

# Активуємо і запускаємо таймер
sudo systemctl enable test.timer; sudo systemctl start test.timer

# Виконуємо перезавантаження VM, і перевіряємо ще раз
sudo systemctl reboot
```

Додаткові команди

```bash
# Якщо знадобиться редагування
sudo systemctl edit --full test.timer
sudo systemctl daemon-reload; sudo systemctl restart test.timer

# Зупиняємо і дезактивуємо таймер
sudo systemctl stop test.timer; sudo systemctl disable test.timer
```

## Аналіз і моніторинг

### Утиліта `systemd-analyze`

Синтаксис: `systemd-analyze [OPTIONS] COMMAND`

Без опцій і підкоманд відображає статистику завантаження системи.

- `systemd-analyze blame` — статистика по кожному юніту

- `systemd-analyze critical-chain` — дерево за часом завантаження

- `systemd-analyze calendar` — перевірка значення OnCalendar для таймера

```bash
# Перевіряємо коли наступного разу буде запущено таймер
systemd-analyze calendar weekly
# Також можна `daily`, `hourly`, `monthly`
```

## Активність сервісів

- `systemd-cgtop` — інтерактивна статистика

## Перегляд журналів

### Утиліта journalctl

Загальносистемні

```bash
# Логи всіх завантажень
journalctl

# Список останніх завантажень
journalctl --list-boots

# Перегляд логів завантаження за номером або хеш-ID
journalctl -b -1
journalctl -b c8db57fa17614054b4defdf5fcc084c2

# Тільки логи ядра
journalctl -k
journalctl -k -b -2

# Переглянути останні 10 записів
journalctl -n 10

# У реальному часі
journalctl -f
```

Фільтрація за часом та датою

```bash
journalctl --since "2023-03-21 19:25:00"
journalctl --since yesterday
journalctl --since 10:00 --until "1 hour ago" -u nginx.service
```

Фільтрація через `grep`

```bash
journalctl -b -u ssh.service --grep Accepted
```

Фільтрація за юнітами

```bash
# Подивитися всі логи завантаження певної служби
journalctl -u nginx.service

# Подивитися логи завантаження певної служби в поточному завантаженні
journalctl -b -u nginx.service
```

Фільтрація за процесами, користувачами та групами

```bash
journalctl _PID=381
journalctl -F _UID
journalctl _UID=1000
journalctl _UID=$(id -u itadmin)
journalctl -F _GUID
journalctl _GUID=1000
```

Фільтрація за рівнем помилок

```bash
# Відобразимо всі повідомлення WARNING за ідентифікатором "4"
journalctl -p 4 -b
# 0:emergency — непрацездатність системи
# 1:alerts — попередження, що вимагають негайного втручання
# 2:critical — критичний стан
# 3:errors — помилки
# 4:warning — попередження
# 5:notice — повідомлення
# 6:info — інформаційні повідомлення
# 7:debug — налагоджувальні повідомлення
```

Додаткові можливості

```bash
# Виведення без обробника сторінок
journalctl --no-pager

# Наприклад зручно використовувати з `lnav`
journalctl -b -u ssh.service --no-pager | lnav

# Детальніше
man systemd.journal-fields
```

### Утиліта `lnav`

_Logfile Navigator_ — інтерактивна утиліта навігації, фільтрації, пошуку та аналізу журналів подій. Зручна та інтуїтивно зрозуміла альтернатива `cat` та `grep`.

![lnav](images/lnav.png)