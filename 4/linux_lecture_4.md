# Розділ 4: Керування користувачами

## Фундаментальні поняття

Багатозадачність сучасних систем дозволяє одночасно виконувати різні задачі для різних користувачів, а також забезпечує можливість розділити ресурси системи між різними користувачами, надаючи їм власні облікові записи, персоналізовані права доступу та середовище (системне оточення).

> **Multitasking (багатозадачність)** — здатність операційної системи виконувати одночасно більше одного завдання чи програми. Дозволяє більш ефективно використовувати ресурси системи, розподіляючи їх між різними процесами і власниками цих процесів.
> **Multiuser (багатокористувацькість)** — можливість багатьох користувачів одночасно працювати з системою, забезпечуючи ізоляцію даних і ресурсів між різними користувачами. Кожен користувач має свій власний обліковий запис і може взаємодіяти з системою незалежно від інших користувачів.

Усі процеси в багатокористувацьких системах виконуються від імені визначених користувачів. Це безпосередньо пов'язано з правами доступу до файлових ресурсів і будь-яких інформаційних об'єктів, наприклад баз даних або каталогів.

Адміністрування користувачів і груп є однією з базових навичок, яка дає змогу забезпечувати ефективність і безпеку використання системних ресурсів.

### Інформаційна безпека

При адмініструванні багатокористувацьких систем, важливо забезпечувати певні заходи та стратегії спрямовані на забезпечення конфіденційності, цілісності та доступності інформації в інформаційних системах.
> **Конфіденційність** — забезпечення того, що лише авторизовані користувачі мають доступ до конфіденційної інформації. Реалізується механізмами аутентифікації та контролю доступу для захисту облікових записів.
> **Доступність** — забезпечення доступності інформації для авторизованих користувачів у визначений час, та запобігання атакам, спрямованим на перешкоджання доступу до ресурсів.
> **Цілісність** — захист від незаконних змін або втрати даних. Забезпечується системами контролю версій і резервного копіювання, а також механізмами перевірки цілісності даних.

### Питання концепції AAA

Як зазначалося раніше, інформаційна безпека базується на концепції AAA, яка визначається трьома ключовими питаннями, що стосуються аутентифікації, авторизації та аудиту.

1. **"Хто ви?"** — *Authentication (аутентифікація):*

- підтвердження ідентичності суб'єкта (користувача, програми, системи).
- може включати введення пароля, використання ключів або інших методів.

1. **"Що ви можете робити?"** — *Authorization (авторизація)*

- визначає, які конкретні ресурси або операції доступні аутентифікованому суб'єкту.
- надання прав обумовлюється системами контролю доступу (DAC та MAC)

1. **"Що було зроблено?"** — *Accounting (облік та аудит)*

- ведення журналу та аналіз подій для відстеження активності суб'єкта та виявлення можливих загроз.
- аудит дозволяє відстежувати дотримання правил безпеки та виявляти аномальні події та вторгнення.

## Аутентифікація

В Linux існує декілька варіантів аутентифікації користувачів.

1. **User IDs (Login/Password)**

- Класичний метод аутентифікації для багатьох систем Linux, користувач для входу в систему вказує своє ім'я та пароль.
- Використовуються файли `/etc/passwd` для облікових записів, `/etc/shadow` для паролів.

1. **Ключі SSH (SSH Keys)**

- Використовується для захищеного мережевого доступу через SSH за допомогою пари ключів (приватний та публічний).
- Публічний ключ додається до файлу `~/.ssh/authorized_keys` на сервері, приватний ключ — на комп'ютері користувача.

1. **Pluggable Authentication Modules (PAM)**

- Стандартний механізм, який використовується багатьма програмами та службами в Linux для розширення і керування методами аутентифікації.
- Включає різні модулі для різних методів аутентифікації, таких як паролі, біометрія, одноразові паролі тощо.

1. **Kerberos**

- Протокол аутентифікації, який дозволяє користувачам отримувати токени безпеки для доступу до різних ресурсів.
- Зазвичай використовується у розподілених середовищах для забезпечення безпеки мережевого зв'язку та аутентифікації.

1. **LDAP (Lightweight Directory Access Protocol)**

- Використовується для централізованого зберігання інформації про користувачів та їх аутентифікації в розподілених системах.
- Дозволяє користувачам входити в систему, використовуючи облікові дані, які зберігаються на сервері LDAP.

1. **OAuth та OpenID Connect**

- Використовуються для аутентифікації користувачів у вебдодатках та забезпечують одноразовий вхід за допомогою облікових записів соціальних мереж чи інших сервісів.
- Розповсюджені у веброзробці для спрощення процесу аутентифікації.

### Класична аутентифікація

#### Типи облікових записів

> **Користувач (User)** — індивідуальний обліковий запис, який дозволяє особі входити в систему та використовувати її ресурси. Кожен користувач має унікальний ідентифікатор користувача (UID), який визначає його у системі.

Для забезпечення безпеки та правильної роботи системи застосовуються спеціальні облікові записи, які використовуються для обробки системних функцій і завдань. Також вони дозволяють залежно від функціональності розмежовувати доступ до ресурсів.
> **Спеціальні облікові записи** — використовуються для певних цілей та спеціальних завдань, які виходять за рамки звичайного користування.

**Основні системні користувачі:**

1. **root (суперкористувач)** — адміністраторський обліковий запис, який має найвищі привілеї в системі, може виконувати будь-які операції та має повний доступ до всіх ресурсів. Необхідний для управління системою, встановлення програм, налаштування параметрів безпеки тощо.
2. **daemon** — використовується для запуску та управління фоновими службами чи демонами (наприклад, вебсервери, бази даних тощо). Дозволяє службам працювати в обмеженому середовищі та зменшує ризики.
3. **nobody** — зазвичай використовується для запуску служб та процесів, які не повинні мати привілеї доступу до ресурсів чи файлів, які належать користувачам. Допомагає уникнути потенційних безпекових проблем, пов'язаних з несанкціонованим доступом.
4. **bin, sys, adm, інші** — використовуються для виконання конкретних завдань та операцій з системними файлами, збір інформації для системного адміністрування та інше.

Користувачі можуть належати до однієї або декількох груп, які дозволяють спільно керувати правами доступу.
> **Групи (Group)** — адміністративне поєднання користувачів для ефективного контролю прав доступу до файлів та інших ресурсів. Кожна група також має унікальний ідентифікатор групи (GID).

#### Базові команди адміністрування користувачів

`useradd` — створює новий обліковий запис або оновлює інформацію для наявного

- створити нового користувача, використовуючи значення за замовчуванням для ідентифікатора користувача та групи, домашнього каталогу та оболонки.

 ```bash
 sudo useradd testuser01
 ```

- оновити інформацію для чинного користувача, встановлюючи оболонку, каталог скелета та поле коментаря за допомогою опцій

 ```bash
 sudo useradd -s /bin/csh -m -k /etc/skel -c "Test User-01"
 ```

основні ключі та опції:

- `-b` - базовий каталог для розміщення домашнього каталогу користувача, за замовчуванням `/home`;
- `-с` - коментар до облікового запису;
- `-d` - домашній каталог, у якому розміщуватимуться файли користувача;
- `-е` - дата, коли обліковий запис користувача буде заблоковано, у форматі ГГГГ-ММ-ДД;
- `-f` - заблокувати обліковий запис відразу після створення;
- `-g` - основна група користувача;
- `-G` - список додаткових груп;
- `-k` - каталог із шаблонами конфігураційних файлів;
- `-l` - не зберігати інформацію про входи користувача в lastlog і faillog;
- `-m` - створювати домашній каталог користувача, якщо він не існує;
- `-М` - не створювати домашню директорію;
- `-N` - не створювати групу з ім'ям користувача;
- `-о` - дозволити створення користувача linux з неунікальним ідентифікатором UID;
- `-р` - задати пароль користувача;
- `-r` - створити системного користувача, який не має оболонки входу, без домашньої директорії та з ідентифікатором до SYS_UID_MAX;
- `-s` - командна оболонка для користувача;
- `-u` - ідентифікатор для користувача;
- `-D` - відобразити параметри, які використовуються за замовчуванням для створення користувача. Якщо разом із цією опцією задати ще який-небудь параметр, то його значення за замовчуванням буде перевизначено.

`adduser` — інтерактивний скрипт додавання користувача

- створити нового користувача

 ```bash
 sudo adduser testuser02
 ```

`id` — вивід інформації про користувача

- показує ідентифікатори та групи, до яких належить користувач.

 ```bash
 id testuser01
 ```

`passwd` — зміна пароля користувача

- дозволяє змінювати пароль для конкретного користувача

 ```bash
 sudo passwd testuser01
 ```

- блокування та розблокування облікового запису

 ```bash
 sudo passwd -l testuser01 # блокування
 sudo passwd -u testuser01 # розблокування
 ```

`usermod` — зміна облікового запису користувача

- додавання користувача в групи, наприклад в адміністратори (sudo)

 ```bash
 sudo usermod -aG sudo testuser01
 ```

`userdel` — видалення користувача

- видаліть користувача разом із його домашнім каталогом та поштою

 ```bash
 sudo userdel -r testuser01
 ```

#### Файли облікових записів та груп

`/etc/passwd` — список користувачів

- файл містить запис/рядок для кожного користувача

 ```bash
 cat /etc/passwd
 ```

![/etc/passwd](images/Example7-2.png)

- поля розділені двокрапкою (`:`).
- **user_name** — унікальне ім'я користувача
- **password** — або хешований пароль, або символ заміщення "x", якщо використовується `/etc/shadow`
- **UserID (UID)** — ідентифікаційний номер користувача

 ```bash
 awk -F: '$3 < 1000' /etc/passwd # UID = 0-999 — Системні облікові записи
 awk -F: '$3 >= 1000' /etc/passwd # UID = 1000-65535 — Користувацькі облікові записи
 ```

- **GroupID (GID)** — первинний груповий ідентифікаційний номер користувача
- **comment** — область коментарів, зазвичай справжнє ім'я користувача
- **home** — домашній каталог користувача
- **shell** — абсолютний шлях до оболонки користувача

![passwd fields](images/Figure7-1.png)

`/etc/shadow` — файл тіньових паролів

- файл містить один запис/рядок для кожного користувача

 ```bash
 sudo cat /etc/shadow
 ```

- поля розділені двокрапкою (`:`)
- **user_name** — унікальне ім'я користувача
- **password** — хешоване (sha512) значення пароля
- **last_change** — днів з 1 січня 1970 року, коли цей пароль востаннє змінювався
- **min_days** — мінімум днів до зміни пароля
- **max_days** — максимальна кількість днів, після закінчення яких необхідно змінити пароль
- **warn** — за скільки днів до закінчення терміну дії пароля користувач буде попереджений
- **grace** — через скільки днів після закінчення терміну дії пароля обліковий запис буде відключено
- **expire** — дата, коли обліковий запис відключено/буде відключено
- **reserved** — зарезервоване поле

`/etc/group` — список груп та їх учасників

- файл містить один запис/рядок для кожної групи

 ```bash
 cat /etc/group
 ```

- поля розділені двокрапкою (`:`)
- **group_name** — назва групи
- **password** — зазвичай пароль не використовується, тому він є порожнім
- **GroupID (GID)** — ідентифікаційний номер групи
- **group_list** — список імен користувачів, які є членами групи

![/etc/group fields](images/Figure7-2.png)

#### Підвищення привілеїв

Команди `su` і `sudo` використовуються для отримання підвищених (адміністративних) привілеїв в середовищі Unix-подібних операційних систем. Основна відмінність між ними полягає в тому, як вони дозволяють користувачам отримувати доступ до підвищених привілеїв та в управлінні цим доступом.

`su` — Switch User

- використовується для тимчасового зміни користувача в іншого, включаючи суперкористувача (root).
- **Спосіб використання:** Коли ви викликаєте `su`, вам потрібно ввести пароль користувача, до якого ви хочете перейти. Після цього весь ваш сеанс командного рядка виконуватиметься в контексті нового користувача.
- **Потребує прав адміністратора:** Зазвичай, для використання `su` потрібні права адміністратора, тобто вам потрібно ввести пароль суперкористувача (root).

- Приклад використання

 ```bash
 su - username
 ```

`sudo` — Superuser Do

- дозволяє користувачам виконувати окремі команди або виконувати командний рядок з підвищеними привілеями, зазвичай у контексті суперкористувача (root).

- **Спосіб використання:** Команда викликається перед командою, яку ви хочете виконати з підвищеними привілеями. Користувач повинен бути включений до списку користувачів, які мають право використовувати `sudo`.

- **Потребує прав адміністратора:** Користувач повинен вводити свій власний пароль, а не пароль суперкористувача.

 Приклад використання `sudo`:

 ```bash
 sudo command
 ```

>**Важливо**
>
> - Використання `sudo` дозволяє адміністраторам системи відстежувати та контролювати, які команди виконуються в системі, і надає більший рівень контролю над дозволами користувачів.
> - Користувачі, які включені до групи `sudoers`, можуть використовувати `sudo` для виконання команд з підвищеними привілеями.

### Додавання користувача в `sudoers`

Для додавання користувача до файлу `sudoers` у Linux, щоб надавати йому можливість виконувати команди з привілеями суперкористувача (root), можна скористатися командою visudo. Вона відкриває файл `sudoers` у текстовому редакторі та дозволяє редагувати його безпечно. Ось кроки, які слід виконати:

1. Запустіть термінал на вашій системі.

1. Виконайте команду:

 ```bash
 sudo visudo
 ```

1. У відкритому файлі `sudoers` додайте рядок, що встановлює правило для вашого користувача. Наприклад, якщо ви хочете додати користувача "user1", щоб він міг виконувати будь-які команди з привілеями суперкористувача, додайте наступний рядок:

 ```bash
 user1 ALL=(ALL:ALL) ALL
 ```

1. Збережіть зміни та закрийте текстовий редактор. Важливо використовувати саме команду `visudo`, оскільки вона дозволяє перевірити синтаксис файлу `sudoers` перед збереженням, щоб уникнути можливих проблем із правами доступу.

Тепер користувач "user1" буде мати можливість виконувати команди з привілеями суперкористувача за допомогою `sudo`. Важливо використовувати цю функцію обережно, щоб уникнути неправильного використання привілеїв суперкористувача, оскільки це може створити загрозу безпеці вашої системи.

## Авторизація та контролю доступу

До контролю доступу в інформаційних системах існує два різні підходи.

### Discretionary Access Control (DAC)

Дискреційний контроль доступу, права доступу до об'єктів контролюються власником цих об'єктів.

- Базовий підхід у системах файлової безпеки в UNIX-подібних операційних системах.

- *Контроль доступу:* Гнучкий, здійснюється власником об'єкта.

- *Політика безпеки:* Децентралізована, залежить від рішень власників об'єктів.

- *Гнучкість:* Велика, користувачі можуть визначати, кому і які права доступу вони надають до своїх ресурсів.

- *Приклади:* `chmod`, `chown` і `chgrp`

#### Власник та права доступу

Кожен файл або каталог має власника та призначену групу, при цьому в одного файлу може бути тільки один власник.
> **Власник (Owner)** — це користувач, який має права доступу до файлу чи ресурсу.

Авторизація можливих дій з файлами та об'єктами визначається правами доступу, що у базовій парадигмі файлових систем Unix налаштовуються окремо тільки для трьох сутностей — **Owner** (власник), **Group** (група) та **Other** (інші користувачі).
> **Права доступу (Permissions)** — визначають, які дії можуть виконувати користувачі відносно файлів чи каталогів (читати, писати, виконувати).

Також існують модулі, які дають можливість керувати правами доступу через розширені списки доступу — Access Control List (ACL).

### Mandatory Access Control (MAC)

Мандатний контроль доступу, права доступу до об'єктів (файлів, процесів, ресурсів) задаються політиками безпеки на рівні системи, а не власником або користувачем.

- Використовується для забезпечення вищого рівня безпеки в системі, обмежуючи доступ користувачів з врахуванням заздалегідь визначених політик.
- *Контроль доступу:* Жорсткий, заданий на рівні системи.
- *Політика безпеки:* Заздалегідь визначена централізованою політикою безпеки.
- *Гнучкість:* Обмежена, менше можливостей для користувачів налаштовувати права доступу.
- *Приклади:* SELinux, AppArmor.

#### `SELinux`

`SELinux` (Security-Enhanced Linux) - це мандатний механізм контролю доступу в Linux, що забезпечує додатковий рівень безпеки, встановлюючи додаткові обмеження на процеси та ресурси. Основна ідея полягає в тому, щоб надати кожній системній операції, додатку та користувачеві лише ті права, які вони дійсно потребують для виконання своєї роботи, що дозволяє обмежити можливість пошкодження системи у разі компрометації.

Політика безпеки в SELinux визначає, які дії дозволені для кожного типу об'єктів (файлів, процесів, портів тощо) та які дії заборонені. Вона ґрунтується на концепції міток безпеки (security labels), які присвоюються об'єктами та суб'єктам (процесам, користувачам) в системі. Мітки безпеки вказують дозволені дії та взаємодію між об'єктами в системі.

SELinux використовує матричну модель безпеки, де дії суб'єктів на об'єкти обмежуються залежно від їхніх міток безпеки. Це дозволяє точно контролювати доступ та забезпечувати високий рівень безпеки системи.

Основні поняття в політиці безпеки SELinux:

- Мітка безпеки (Security label): Інформація, що прив'язується до об'єкта (файлу, процесу тощо) і вказує дозволені дії для цього об'єкта.
- Контекст безпеки (Security context): Комбінація мітки безпеки та додаткової інформації, яка визначає, як поводить себе об'єкт в системі.

SELinux може бути у різних режимах роботи:

- Enforcing: При строгому режимі SELinux блокує доступ до ресурсів, якщо це суперечить встановленій політиці безпеки.
- Permissive: У режимі пермісії SELinux не блокує доступ, але веде запис про потенційні порушення політики.

Правильно налаштована політика безпеки SELinux може значно підвищити безпеку системи, ускладнюючи атакам взаємодію з системою та мінімізуючи можливі наслідки вразливостей.

## Аудит

- **Призначення:** Аудит служить для збору та аналізу журналів подій системи для виявлення потенційних загроз та слідів вторгнень.
- **Застосування:** Забезпечує механізм аудиту для вивчення подій, таких як входження в систему, зміни файлів тощо.

### Перегляд журналу аудиту

`/var/log/auth.log` — журнал аудиту

1. **Перегляд усіх записів використання sudo**:

 ```bash
 sudo grep -E 'sudo' /var/log/auth.log
 ```

1. **Перегляд усіх використань sudo користувачем user1**:

 ```bash
 sudo grep -E 'sudo:.*user1' /var/log/auth.log
 ```

1. **Перегляд усіх використань sudo для конкретної команди**:

 ```bash
 sudo grep -E 'sudo:.*<COMMAND>' /var/log/auth.log
 ```

 Замість `<COMMAND>` введіть команду, яку ви шукаєте, наприклад, `sudo:.*ls`.

1. **Перегляд усіх використань sudo під час певного періоду**:

 ```bash
 sudo grep -E 'sudo' /var/log/auth.log | grep '2024-02-25 10:'
 ```

 Замініть `2024-02-25 10:` на дату та час, які вас цікавлять.

Ці команди використовують журнал аутентифікації `/var/log/auth.log`, який зазвичай містить інформацію про використання sudo на системі. Ви можете використовувати аналогічний підхід для інших системних журналів, якщо вони налаштовані для ведення журналів дій користувачів.

### Інші системні журнали

На Linux і Unix-подібних системах є кілька системних журналів, які використовуються для різних цілей і містять різну інформацію про різні аспекти системи. Кілька типових системних журналів:

1. **/var/log/messages або /var/log/syslog**: Цей журнал містить загальну системну інформацію, таку як повідомлення про завантаження, перезавантаження, системні події та помилки.

2. **/var/log/auth.log або /var/log/secure**: Цей журнал містить інформацію про аутентифікацію, таку як вхід в систему, використання sudo, зміни паролів і подібне.

3. **/var/log/kern.log**: Цей журнал містить повідомлення ядра, такі як повідомлення про помилки, попередження та інші події, пов'язані з ядром.

4. **/var/log/boot.log**: Цей журнал містить інформацію про процес завантаження системи, таку як завантаження модулів ядра та інші події.

5. **/var/log/dmesg**: Цей файл містить вивід ядра, який генерується під час завантаження системи. Він містить корисну інформацію про апаратне забезпечення та інші діагностичні повідомлення.

6. **/var/log/lastlog**: Цей файл містить інформацію про останній вхід користувачів у систему.

7. **/var/log/audit/audit.log**: Цей журнал містить журнал подій аудиту, який може бути використаний для аудиту безпеки системи.

## PAM

PAM (**Pluggable Authentication Modules**) — це система під GNU/Linux, яка дозволяє багатьом програмам або службам централізовано автентифікувати користувачів.

Іншими словами, PAM — це набір бібліотек, який дозволяє системному адміністратору Linux налаштовувати методи аутентифікації користувачів. Він забезпечує гнучкий і централізований спосіб перемикання методів аутентифікації для захищених програм за допомогою файлів конфігурації замість зміни коду програми.

### Загальні положення

Аутентифікація — це етап, під час якого перевіряється, що ви є особою, за яку себе видаєте. Найпоширенішим прикладом є пароль, але існують і інші форми аутентифікації. Реалізація нового методу аутентифікації не повинна вимагати змін у вихідному коді конфігурації програми чи служби. Ось чому програми покладаються на PAM, який надає їм примітиви, необхідні для аутентифікації своїх користувачів. Таким чином, усі програми в системі можуть реалізувати такі складні функції, як SSO (єдиний вхід), OTP (Одноразовий пароль) або Kerberos в абсолютно прозорий спосіб. Системний адміністратор може вибрати, яку саме політику аутентифікації використовувати для окремої програми (наприклад, для посилення служби SSH) незалежно від програми.

Кожна програма або служба, що підтримує PAM, матиме відповідний файл конфігурації в каталозі `/etc/pam.d/`. Наприклад, процес login призначає назву `/etc/pam.d/login` своєму файлу конфігурації.

- **Примітиви** — це буквально найпростіші елементи програми або мови, які дозволяють створювати на їх основі більш витончені та складні речі.

**Увага:** Неправильно налаштований екземпляр PAM може поставити під загрозу безпеку всієї системи. Якщо PAM вразливий, то вразлива вся система. Робіть будь-які зміни обережно.

### Директиви

Директива використовується для налаштування програми для використання з PAM. Директиви матимуть такий формат:

```bash
mechanism [control] path-to-module [argument]
```

**Директива** (повний рядок) складається з **механізму** (`auth`, `accout`, `session`, `password`), **перевірка успіху** (`include`, `optional`, `required`, ...), **шлях до модуля** та, можливо, **аргументи** (наприклад, `revoke`).

Кожен файл конфігурації PAM містить набір директив. Директиви інтерфейсу модуля можна складати або розміщувати одна на одній. Насправді **порядок, у якому перераховані модулі, дуже важливий для процесу аутентифікації**.

Приклад файлу конфігурації PAM:

```bash
auth sufficient pam_rootok.so
auth requisite pam_shells.so
auth sufficient pam_unix.so
auth required pam_deny.so
```

![PAM steps](images/Figure7-4.png)

### Механізми

`auth` – аутентифікація

Це забезпечує аутентифікацію запитувача та встановлює права облікового запису:

- Зазвичай автентифікується за допомогою пароля, порівнюючи його зі значенням, що зберігається в базі даних, або покладаючись на сервер аутентифікації,
- Встановлює параметри облікового запису: uid, gid, групи та обмеження ресурсів.

`account` – керування обліковим записом

Перевіряє доступність запитуваного облікового запису:

- Пов’язано з доступністю облікового запису з причин, відмінних від аутентифікації (наприклад, через часові обмеження).

`session` – керування сеансом

Змінює налаштування та завершення сеансу:

- Виконує завдання, пов’язані з налаштуванням сеансу (наприклад, журналювання),
- Виконує завдання, пов'язані із завершенням сесії.

`password` – керування паролями

Використовується для зміни маркера аутентифікації, пов’язаного з обліковим записом (закінчення терміну дії або зміна):

- Змінює маркер аутентифікації та, можливо, перевіряє, чи він достатньо надійний або ще не використовувався.

### Контрольні індикатори

Механізми PAM (`auth`, `account`, `session` і `password`) вказують на **успіх** або **помилку**. Контрольні прапорці (`required`, `requisite`, `sufficient`, `optional`) повідомляють PAM, як обробляти цей результат.

`required`

Успішне завершення всіх required модулів є необхідним.

- **Якщо модуль завершується успішно:** решта ланцюжка виконується. Запит дозволений, якщо інші модулі не дають збою.
- **Якщо модуль завершується неуспішно:** виконується решта ланцюжка. Зрештою запит буде відхилено.

Для продовження аутентифікації модуль має бути успішно перевірено. Якщо перевірка модуля, позначеного як `required`, не вдається, користувач не отримує сповіщення, доки не буде перевірено всі модулі, пов’язані з цим інтерфейсом.

`requisite`

Необхідно успішне проходження всіх *необхідних* модулів.

- **Якщо модуль завершується успішно:** решта ланцюжка виконується. Запит дозволений, якщо інші модулі не дають збою.
- **Якщо модуль завершується неуспішно:** запит негайно відхиляється.

Для продовження аутентифікації модуль має бути успішно перевіреним. Проте, якщо перевірка модуля, позначеного `requisite`, не вдається, користувач негайно отримує повідомлення про невдачу першого `required` або `requisite` модуля.

`sufficient`

Модулі з позначкою `sufficient` можуть бути використані, щоб дозволити дію «достроково» за певних умов:

- **Якщо модуль завершується успішно:** Запит на аутентифікацію негайно дозволяється, якщо жоден із попередніх модулів не вдався.

- **Якщо модуль завершується неуспішно:** модуль ігнорується. Решта ланцюжка виконується.

Проте, якщо перевірка модуля з позначкою `sufficient` пройшла успішно, але модулі з позначкою `required` або `requisite` не пройшли перевірки, успіх модуля `sufficient` ігнорується, і запит не виконується.

`optional`

Модуль виконується, але результат запиту ігнорується. Якби всі модулі в ланцюжку були позначені як `опціональні`, усі запити завжди приймалися б.

![PAM indicators](images/pam_indicators.png)

### Модулі PAM

Існує багато модулів для PAM. Ось найпоширеніші з них:

- `pam_unix`
- `pam_ldap`
- `pam_wheel`
- `pam_cracklib`
- `pam_console`
- `pam_tally`
- `pam_securetty`
- `pam_nologin`
- `pam_limits`
- `pam_time`
- `pam_access`

#### **pam_unix**

Модуль `pam_unix` дозволяє вам керувати глобальною політикою аутентифікації. У `/etc/pam.d/system-auth` можна додати:

```bash
password sufficient pam_unix.so sha512 nullok
```

Для цього модуля можливі аргументи:

- `nullok`: у механізмі auth дозволяє порожній пароль для входу.
- `sha512`: визначає алгоритм шифрування в механізмі пароля.
- `debug`: надсилає інформацію до syslog.
- `remember=n`: використовуйте це, щоб запам’ятати останні n використаних паролів
  (працює разом із файлом `/etc/security/opasswd`, який створюється адміністратором).

#### **pam_cracklib**

Модуль `pam_cracklib` дозволяє перевіряти паролі. У `/etc/pam.d/password-auth` додайте:

```bash
password sufficient pam_cracklib.so retry=1
```

Цей модуль використовує бібліотеку cracklib для перевірки надійності нового пароля. Він також може перевірити, чи новий пароль не побудовано на основі старого. Це *лише* впливає на механізм пароля.

За замовчуванням цей модуль перевіряє наступні аспекти та відхиляє, якщо це так:

- Чи це новий пароль зі словника?
- Чи є новий пароль паліндромом старого (наприклад: azerty <> ytreza)?
- Користувач змінив лише регістр пароля (наприклад, azerty <>AzErTy)?

Можливі аргументи для цього модуля:

- `retry=n`: робить n запитів (1 за умовчанням) для нового пароля.
- `difok=n`: вимагає принаймні n символів (10 за умовчанням), відмінних від старого пароля. Якщо половина символів нового пароля відрізняється від старого, новий пароль вважається дійсним.
- `minlen=n`: вимагає пароль мінімум з n+1 символів. Ви не можете призначати мінімум менше ніж 6 символів (модуль скомпільовано таким чином).

Інші можливі аргументи:

- `dcredit=-n`: вимагає пароль, що містить щонайменше n цифр,
- `ucredit=-n`: вимагає пароль, що містить принаймні n великих літер,
- `lcredit=-n`: вимагає пароль, що містить принаймні n малих літер,
- `ocredit=-n`: вимагає пароль, що містить принаймні n спеціальних символів.

#### **pam_tally**

Модуль `pam_tally` дозволяє блокувати обліковий запис після кількох невдалих спроб входу. Типовий файл конфігурації для цього модуля може виглядати так:

```bash
/etc/pam.d/system-auth:
auth required /lib/security/pam_tally.so onerr=fail no_magic_root
account required /lib/security/pam_tally.so deny=3 reset no_magic_root
```

Механізм auth приймає або забороняє аутентифікацію та скидає лічильник. Механізм account збільшує лічильник.

Деякі аргументи модуля pam_tally включають:

- `onerr=fail`: збільшує лічильник.
- `deny=n`: після перевищення кількості n невдалих спроб обліковий запис блокується.
- `no_magic_root`: можна використовувати для заборони доступу до служб кореневого рівня, запущених демонами. Наприклад, не використовуйте це для su.
- `reset`: скидає лічильник до 0, якщо аутентифікацію перевірено.
- `lock_time=nsec`: обліковий запис заблоковано на n секунд.

Цей модуль працює разом із файлом за замовчуванням для невдалих спроб `/var/log/faillog` (який можна замінити іншим файлом з аргументом `file=xxxx`) і пов’язаним з командою `faillog`.

#### **pam_time**

Модуль `pam_time` дозволяє обмежити час доступу до служб, якими керує PAM. Щоб активувати його, відредагуйте `/etc/pam.d/system-auth` і додайте:

```bash
account required /lib/security/pam_time.so
```

Налаштування виконується у файлі `/etc/security/time.conf`:

```plaintext
login ; *; users ; MoTuWeThFr0800-
http ; * ; users ; Al0000-
```

Синтаксис директиви наступний:

```plaintext
services; ttys; users; times
```

У наведених нижче визначеннях логічний список використовує:

- `&`: логічне значення "і".
- `|`: логічне "або".
- `!`: означає заперечення або "всі, крім".
- `*`: символ підставлення.

Стовпці відповідають:

- services: логічний список служб, керованих PAM, якими також керуватиме це правило
- ttys: логічний список пов’язаних пристроїв
- users: логічний список користувачів, керованих правилом
- times: логічний список авторизованих часових інтервалів

Як керувати часовими інтервалами:

- Дні: Mo, Tu, We, Th, Fr, Sa, Su, Wk (з понеділка по п’ятницю), Wd (субота та неділя) та Al (з понеділка по неділю)
- Погодинний діапазон: HHMM-HHMM
- Повторення скасовує ефект: WkMo = усі дні тижня (пн-пт), мінус понеділок (повтор).

Приклади:

- Боб, можна входити через термінал щодня з 07:00 до 09:00, крім середи:
  `login; tty*; bob; alth0700-`
- Без входу, терміналу чи дистанційного входу, окрім root, щодня з 17:30 до 7:45 наступного дня:
  `login; tty* | pts/*; !root; !wk1730-`

#### **pam_nologin**

Модуль pam_nologin вимикає всі облікові записи, крім root. У `/etc/pam.d/login` потрібно вказати:

```bash
auth required pam_nologin.so
```

Тільки root може під'єднатися, якщо існує файл `/etc/nologin`.

#### **pam_wheel**

Модуль pam_wheel дозволяє обмежити доступ до команди su членам групи wheel. У `/etc/pam.d/su` ви повинні розмістити:

```bash
auth required pam_wheel.so
```

Аргумент `group=my_group` обмежує використання команди su членами групи my_group.

**Примітка**: Якщо група my_group порожня, то команда su більше не доступна в системі, що змушує використовувати команду sudo.

### [Практика : Встановлення Google 2FA](https://ubuntu.com/tutorials/configure-ssh-2fa)
