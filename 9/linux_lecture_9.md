## Розділ 9: Керування процесами

Навички управління процесами в операційній системі Linux, є важливим заняттям для системних адміністраторів, розробників і DevOps. Це дає змогу ефективно керувати та моніторити роботу систем, оптимізувати використання ресурсів та забезпечувати стабільність і продуктивність інфраструктури.

### Фундаментальні поняття

![System-Call-Interface](images/05-1_System-Call-Interface.png "System-Call-Interface")

#### Програми та процеси

Головна функція комп'ютерних систем — виконання завдань інформаційного опрацювання даних. Це виконується за певним алгоритмом, який представлений у вигляді машинно-виконуваного бінарного коду (програм), або інтерпритованих сценаріїв (скриптів).

> **Program (програма)** — це масив бінарного коду, що реалізує алгоритми та інструкції обробки інформації для виконання певних функцій та завдань.

В ідеології Linux говорять про процес, як деяку абстрактну сутність "обробник", який виконує програму. Ядро операційної системи створює для обробника віртуальне середовище. Зокрема воно виділяє та обслуговує ресурси обробника, такі як процесорний час, пам'ять і дисковий простір.

> **Processes (процес)** — це обробник програми, що виконується у віртуальному середовищі операційної системи. Він має свій власний контекст виконання, ресурси й унікальний ідентифікатор.

Поняття процесу повністю корелює з концепцією потоків даних, прийнято говорити, що процес приймає потік даних на вхідний канал, обробляє їх, та повертає дані результату на канал вихідного потоку. Також процес наділяється якостями живої сутності — у нього є батьки і предки, він народжується та має життєвий цикл, у нього можна контролювати здоров'я, його можна вбити і навіть він може стати зомбі.

Для кожної програми, що запускається, створюється окремий процес, якщо запустити одну програму кілька разів, для кожного екземпляра буде створено окремий процес.

#### Багатозадачність

Завдяки контрольованому поділу ресурсів комп'ютера (процесорний час, пам'ять і введення-виведення), операційна система Linux здатна підтримувати кілька процесів одночасно. Це реалізується за рахунок послідовного перемикання процесора між контекстами обробки різних процесів, фактично це псевдо-одночасність.

> **Multitasking (багатозадачність)** — це якість операційної системи одночасно обробляти кілька процесів.

Використання багатозадачності підвищує ефективність використання ресурсів комп'ютера і забезпечує скорочення витрат на інфраструктуру.

#### Планувальник процесів

Основним завданням для реалізації багатозадачності є забезпечення справедливого розподілу слотів процесорного часу (time
slices) між процесами, з огляду на їхні пріоритети та вимоги до ресурсів.

> **Process Scheduler (планувальник процесів)** — компонент операційної системи, що ухвалює рішення про те, який процес має отримати доступ до процесора і на який час. Він також визначає порядок виконання процесів і контролює їхній доступ до ресурсів системи, таких як процесор, пам'ять і введення-виведення.

Відповідно до процесних завдань і налаштувань ядра, планувальник використовує різні алгоритми планування, такі як FIFO (First-In-First-Out), Round Robin, Priority Scheduling, Multilevel Feedback Queue та інші.

1. **FIFO (First-In-First-Out)**: Процеси обробляються в порядку їхнього надходження. Перший прийшов - перший вийшов. Простий у реалізації, але може призводити до проблеми "вибуху контекстного перемикання" (_"context switch explosion"_ - це ситуація, коли занадто велика кількість контекстних перемикань між процесами або потоками призводить до значного збільшення накладних витрат, пов'язаних з управлінням процесором, і може призвести до зниження продуктивності системи).

2. **Round Robin**: Процеси отримують час процесора у визначеному порядку, після чого переходять у кінець черги. Це дозволяє уникнути "вибуху контекстного перемикання" і забезпечити справедливу частку процесорного часу.

3. **Priority Scheduling**: Процеси виконуються в порядку їхнього пріоритету. Процеси з вищим пріоритетом отримують процесор частіше. Може виникнути проблема "виснаження" - процеси з низьким пріоритетом можуть ніколи не виконуватися.

4. **Multilevel Feedback Queue**: Процеси розподіляються по кількох чергах і виконуються в залежності від їхнього пріоритету та інших факторів. Процеси можуть переміщуватися між різними рівнями черги в залежності від їхньої поведінки.

5. **Shortest Job Next (SJN)**: Процесор надається процесу з найменшим часом виконання. Це мінімізує середній час очікування, але вимагає знання часу виконання кожного процесу.

6. **Shortest Remaining Time (SRT)**: Відмінність SJN полягає в тому, що в SRT час виконання процесу може змінюватися в процесі його виконання, і якщо приходить процес з меншим часом виконання, ніж поточний, він може перервати поточний процес.

### Досліджуємо процеси

#### Фонові, інтерактивні та системнні процеси

Залежно від режиму взаємодії з користувачем, усі процеси в Linux можуть належати до одного з типів:

##### Foreground Process (інтерактивний процес)

Команди, запущені користувачем через термінал, зазвичай виконуються на передньому плані і можуть блокувати термінал до їхнього завершення або призупинення.

Інтерактивні процеси:

- не можуть запускатися автоматично самі по собі, для їхнього запуску та виконання в системі має бути користувач
- вони пов'язані із взаємодією з користувачем через командний рядок у термінальній сесії
- процес очікує користувацького введення і може виводити результати на термінал
- під час виконання займає термінал, і користувач може спостерігати його виконання і взаємодіяти з ним

```bash
# Приклади інтерактивного виконання процесу
sleep 15
ping i.ua
```

**`fg`** — (foreground) переведення призупиненого або запущеного у фоновому режимі процесу на передній план

```bash
fg          # Перевести последний процесс в фоновом режиме в передний план
fg [PID]    # Перевести процес із зазначеним PID на передній план.
```

##### Background Process (фоновий процес)

Деякі процеси можуть виконуватися без прямої взаємодії з користувачем, вони працюють у фоновому режимі та не займають термінал.

Фонові процеси:

- під час їх виконання користувач може продовжувати працювати з терміналом, запускаючи та взаємодіючи з іншими процесами
- не очікують введення користувача, але можуть виводити результати на термінал, якщо не вказано інший STDOUT
- зазвичай використовуються для виконання тривалих або автоматизованих завдань, які не потребують безпосередньої участі користувача

```bash
# Приклади виконання процесу у фоновому режимі
sleep 180 &
ping i.ua &

nohup ping i.ua &

# Перегляд фонових процесів поточного сеансу користувача
jobs

# Припинення їх виконання
pkill sleep; pkill ping

# Створюємо найпростіший скрипт
echo "ping i.ua" > my_script.sh && chmod +x my_script.sh
# Запустити скрипт у безтермінальному режимі
nohup ./my_script.sh &
# Перелогінюємося та перевіряємо
ps -eF | grep my_script.sh
```

**`bg`** — (background) відновлення виконання призупиненого процесу у фоновому режимі

```bash
bg          # Відновити виконання останнього призупиненого процесу у фоновому режимі.
bg [PID]    # Відновити виконання процесу із зазначеним PID у фоновому режимі
```

##### System Process (системний процес)

У контексті процесів Linux існує особливий вид фонових процесів "демонів" (Daemon), які не залежать від інтерактивних користувачів і обслуговують певні функції або служби системи. Керування життєвим циклом "демонів" (системних процесів) здійснюється через головний/первинний системний процес init/systemd або запущені під ним системні служби.

Такі процеси:

- виконуються у фоновому режимі, незалежно від дій інтерактивних користувачів
- можуть мати свій власний контекст безпеки (користувача та групу)
- не прив'язані до терміналу і не взаємодіють з користувачем безпосередньо
- можуть бути запущені при завантаженні системи або при виконанні певних умов
- працюють безперервно в автоматичному режимі, і зазвичай ніколи не вмирають
- ними можно керувати (зупинити, переконфігурувати і запустити) через системний процес init / systemd або через скрипти ініціалізації

#### Дерево процесів

Виникнення процесів у Linux починається з моменту ініціалізації ядра. Під час завантаження ядра створюється перший процес з ідентифікатором **`PID=1`**, який називається процесом **`init`** або у сучасних версіях **`systemd`**. Цей процес завантажує необхідні сервіси, драйвери та системні програми, а також стає батьківським процесом для всіх інших процесів у системі.

```bash
#Дивимося на PPID
ps -eF | head

# Дивимося на відношення процесів батько — нащадок
ps -axjf

# Відобразити процеси у вигляді дерева
pstree -a

# Дерево процесів користувача
ps -fx
```

#### Таблиця та структура процесів

Для управління процесами ядро Linux зберігає в спеціальній таблиці інформацію про кожен запущений процес.

- **Process table (PB)** — Таблиця процесів, основний елемент операційної системи для управління та координування виконання процесів. Вона дає змогу відстежувати та контролювати активність кожного процесу, зберігати та відновлювати контекст процесу під час перемикання між ними та надавати необхідні ресурси для їхнього виконання.
- **Process Control Block (PCB)** — Блок керування процесами, це інформація, що використовується для управління процесами. З ним також пов'язане поняття **Process Descriptor** (Дескриптор процесу)

![Table-PCB](images/05-2_Table-PCB.png "Table-PCB")

Основні атрибути та елементи:

- **Ідентифікатор процесу (PID)** — Унікальний числовий ідентифікатор, який відрізняє кожен процес від інших процесів у системі.
- **Батьківський процес (Parent Process)** — Ідентифікатор батьківського процесу, який створив поточний процес.
- **Стан процесу (State)** — Визначає поточний стан процесу, такий як виконується, готовий до виконання, заблокований тощо.
- **Контекст безпеки (Security)** — Ідентифікатори користувача (UID) і групи (GID), які визначають права доступу до ресурсів системи.
- **Ресурси процесу** — Включає інформацію про виділену пам'ять, відкриті файлові дескриптори, мережеві з'єднання та інші ресурси, що використовуються процесом.
- **Інформація про планування** — Містить пріоритет процесу, час, який процес уже виконується, та іншу інформацію, необхідну для планування і розподілу процесорного часу.
- **Контекст обробки процесором** — Зберігає адресу наступної інструкції, яку процесор має виконати для цього процесу, значення його регістрів і стека, прапори стану та інше.

#### Життєвий цикл та стани процесу

Описуваний далі життєвий цикл є загальним орієнтиром для розуміння роботи процесів в операційній системі Linux.

![Process-State](images/05-3_Process-State.png "Process-State")

- **Creation** — Створення новогу процесу:
  - Батьківський процес викликає системну функцію виклику `fork()`
  - Створюється точна копія батьківського процесу, включно з його пам'яттю, файловими дескрипторами, станом і окремим записом у таблиці процесів;
  - Процесу-нащадку присвоюється новий `PID`, а `PPID` (Parent Process Id) змінюється на батьківський `PID`.
- **Rebirth** — Переродження в іншу програму:
  - Процес-потомок може за допомогою системного виклику `exec()` замінити сегменти коду старого процесу на код нової програми;
  - Після створення процес переходить у стан готовності (ready).
- **Ready** — Готовність до виконання:
  - У цьому стані процес очікує своєї черги в планувальнику процесів;
  - Обробка черги залежить від пріоритетів самого процесу та інших процесів у системі.
- **Running** — Виконання або обробка:
  - Коли процес отримує процесорний час від планувальника, він переходить у стан виконання своїх завдань;
  - Процес активно виконується на процесорі і виконує свої завдання.
- **Waiting** — Очікування:
  - Процес може перейти в стан очікування, якщо він очікує на будь-яку подію, наприклад, введення-виведення, завершення іншого процесу або отримання сигналу.
  - У цьому стані процес тимчасово призупиняється і звільняє процесор, поки не відбудеться очікувана подія.
- **Stopped** — Зупинено:
  - у цей стан процес переходить, коли отримує відповідний сигнал SIGSTOP або SIGTSTP, або під час налагодження;
  - процес призупинено і він не займає процесорний час, він очікує подальших інструкцій або дій;
  - зміна цього стану можлива сигналами SIGCONT (продовжити виконання) або SIGTERM (завершити процес).
- **Terminated** — Завершення:
  - У цей стан процес переходить за допомогою системного виклику `exit()`, коли виконав усі свої завдання або отримав сигнал примусового завершення;
  - При цьому стані процес завершує свою роботу, звільняє займані ресурси і виставляє статус про своє завершення;
- **Zombie** — Зомбі
  - Цей стан виникає коли процес завершився, але його батьківський процес ще не отримав через системний виклик `wait()` статус завершення процесу-нащадка;
  - У цьому стані процес процес не виконує жодних операцій і вже звільнив усі займані ресурси;
  - Зомбі-процес це лише запис, яка зберігає статус (код виходу та причину завершення процесу);
  - Цей стан існує доки батьківський процес не виконає системний виклик `wait()` або `waitpid()` і для отримання статусу завершення процесу-нащадка.
    > **Zombie** — це нормальний тимчасовий стан у життєвому циклі процесів. Щоб уникнути накопичення зомбі-процесів у черзі завдань, батьківський процес має своєчасно обробити статус завершення процесу-нащадка.
- **Forgetting** — Забуття
  - Після того, як батьківський процес забрав інформацію про завершення процесу-нащадка, ядро видаляє його запис із таблиці процесів.

![Process-LifeCycles](images/05-4_Process-LifeCycles.png "Process-LifeCycles")

Перехід між станами в життєвому циклі процесу залежить від дій самого процесу або від дій операційної системи, але виконуються тільки через системні виклики: `fork()`, `exec()`, `wait()`, `exit()` та їм подібні.

#### Розглянемо деякі стани процесів

##### Процес в обробці (Running) — `R-state`

Процес використовує або готовий використовувати процесорний час. У одиницю часу тільки один процес може бути в обробці.

```bash
# Команда для перегляду `Running` процесів
ps -rx
# Підрахувати кількість `Running` процесів
ps -e -o stat,pid,cmd | grep "^R" | wc -l
```

##### Процес спить або в стані простою (Sleeping / Idle) — `S-state` / `I-state`

Процес спить/неактивний, очікує події або завершення операції введення-виведення.

```bash
# Підрахувати кількість `Sleeping/Idle` процесів
ps -e -o stat,pid,cmd | grep "^S" | wc -l
ps -e -o stat,pid,cmd | grep "^I" | wc -l
ps -e -o stat,pid,cmd | grep "^[SI]" | wc -l
```

##### Процес зупинено (Stopped) — `T-state`

Процес очікує відновлення виконання (заморожено) й перебуває в пам'яті.

```bash
# Запустимо команду в інтерактивному процесі
ping -c15 i.ua
# Призупинимо її інтерактивний процес натисканням [Ctrl]+[Z]
ps -ux | grep -v grep | grep -w T
# Повернемо процес у стан `running`
fg
# Або відновимо виконання призупиненого процесу у фоновому режимі
bg
```

##### Відстежується/трасування (Traced) — `t-state`

Процес зупинено, але в цей момент до нього під'єднано дебаггер.

```bash
# Пример отладки через `gdb`
sleep 300 &
sleep_pid=$!
gdb -p $sleep_pid
ps -ux | grep sleep
```

##### Процес в обробці (Uninterruptible Sleep) — `D-state`

Процес очікує завершення операції введення-виведення або отримання ресурсу. Стан "блокованого сну" не дає змоги процесу реагувати на більшість сигналів і його не можна перервати або зупинити звичайними засобами.

```bash
# Підрахувати кількість `Uninterruptible Sleep` процесів
ps -e -o stat,pid,cmd | grep "^D" | wc -l
```

> **Важливо:** Процеси в стані "блокованого сну" можуть існувати тривалий час, і це може вказувати на проблеми з введенням-виведенням або інші проблеми в системі. Наприклад, процеси можуть бути заблоковані через проблеми з пам'яттю, дисковою або мережевою підсистемою (обладнання та драйвер).

##### Досліджуємо зомбі (Zombie) — `Z-state`

Процес завершено, але статус завершення не оброблено батьківським процесом.

Створимо програму:

1. Породжує процес-потомок, який одразу завершується;
2. Батьківський процес бере три хвилинну паузу;
3. Закінчує роботу, так і не подбавши про перевірку нащадка.

```c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    pid_t child_pid;
    child_pid = fork();  // Creating a child process
    if (child_pid > 0)
    {
        sleep(180);  // It's a parent process — take a 3-min pause
    }
    else
    {
        exit(0);  // This is a child process — end immediately
    }
    return 0;
}
```

```bash
# Створюємо файл з початковим кодом
vi zombie.c
# Для вставки тексту — [Insert], для збереження та виходу — [Esc]+:wq

# Компілюємо програму
gcc zombie.c -o zombie

# Запускаємо `zombie` у фоні 7 разів
for i in $(seq 1 7); do ~/zombie & done

# Дивимося та аналізуємо
ps aux | grep -w "<defunct>"; pstree -ap $$
```

> **Важливо:** Процес у стані "зомбі" не займає ресурси (процесор і пам'ять) системи, але займає PCB (дескриптор процесу). Якщо таких записів у таблиці процесів буде дуже багато, може бути вичерпано ліміт і ядро не зможе створювати нові процеси.

```bash
# Відобразити максимально допустиму кількість процесів
ulimit -u
ulimit -a | grep "max user processes"
```

Для очищення таблиці процесів від "zombie" достатньо завершити їх батьківський процес, після цього сирітські процеси перейдуть під управління (будуть усиновлені) кореневим процесом `systemd`, який їх автоматично очистить.

#### Пріоритети процесів

Різні завдання, а відповідно і процеси, що їх обслуговують, можуть мати різну терміновість і важливість виконання. Планувальник процесів при виборі черговості надання процесорного часу орієнтується на атрибути пріоритетності.

Основні критерії пріоритетів:

- **За типом процесу** — Залежно від типу процесу (інтерактивний, фоновий або системний) обирається діапазон пріоритетів, що відображають його важливість і терміновість виконання.
- **Користувацький** — Під час запуску програм користувач може задати пріоритет запуску або змінювати пріоритет під час виконання. Зазвичай це робиться з використанням команди `nice`, `renice` та їхніх аналогів.
- **Політикою** — У Linux планувальник процесів використовує алгоритми планування CFS (Completely Fair Scheduler) або O(1), які можуть визначати різні політики та способи управління пріоритетами.

##### Перегляд пріоритетів

Пріоритети процесів виражаються коефіцієнтами (цілими числами), які бути в діапазоні від -20 (вищий пріоритет) до 19 (найнижчий пріоритет).

```bash
# Відобразимо Топ-10 процесів
ps -ely | head -n11

# Або в оптимальнішому вигляді
ps -eo pid,ppid,cmd,pri,nice | head -n11
```

Відображення пріоритетів:

- `PRI` (Priority) — Абсолютный пріоритет процесу, фактично так його бачить ядро, впливати на нього немає можливості.
- `NI` (Nice) — це концепція простору користувача, наскільки процес "гарний", ним можна керувати через програми `nice` и `renice`.

> У сучасних версіях в Linux для управління груп процесів може використовуватися спеціальний просунутий механізм **Cgroups** (Control Groups). Він дає змогу контролювати не тільки використання ресурсів, як-от CPU, пам'ять, дисковий простір, мережевий трафік, а й встановлювати їхні пріоритети.

#### Керуючі сигнали (Control Signals)

Для взаємодії між процесами в операційній системі є особливий механізм, який передає керуючі сигнали активним процесам, та дає змогу керувати життєвим циклом процесу, опрацюванням помилок, зміною поведінки процесу тощо.

- Керуючі сигнали, це програмні переривання, які ідентифікують за унікальним ім'ям або номером;
- У будь-який час роцес може бути перерваний сигналом з ініціативи іншого процесу або ядра для обробки будь-якої події;
- Процес, який отримав сигнал, перериває свою роботу і передає керування обробнику сигналу, після закінчення обробки процес може продовжити роботу;
- Ядро використовує сигнали для сповіщення процесів про різні події, наприклад про завершення дочірнього процесу.

Найкорисніші сигнали:

- **`SIGHUP (1)`** — (Hangup) Сповіщення процесу про розрив зв'язку з терміналом, або під час завершення сесії користувача. Використовується для оновлення налаштувань або реініціалізації процесу. Наприклад, у Nginx, щоб не перезапускати сервіс і тим самим не переривати сесії користувачів, за допомогою нього можна застосувати нову конфігурацію аналогічно команді `systemctl reload nginx`.
- **`SIGINT (2)`** — (Interrupt) Запит завершення процесу, зазвичай надсилається процесу під час отримання сигналу переривання, наприклад, після натискання `[Ctrl]+[C]`.
- **`SIGKILL (9)`** — (Kill) Негайне завершення процесу, його неможливо ігнорувати або обробити.
- **`SIGTERM (15)`** — (Terminate) Коректне завершення роботи, очищення і звільнення ресурсів.
- **`SIGSTOP (19)`** — (Stop) остановить процесс
- **`SIGCONT (18)`** — (Continue) продолжить работу процесса после остановки.

```bash
# Подивитися список усіх сигналів
kill -l
```

#### Псевдо-файлова система `/proc`

Віртуальна файлова система, реалізована через спеціальний механізм, що дає змогу отримувати інформацію про систему від самого ядра, а також передавати інформацію ядру, модулям ядра і його процесам.

Розмір будь-якого файлу в каталозі `/proc` дорівнює "0", але якщо відкрити файл, він міститиме інформацію. Це пояснюється тим, що вміст файлу формується "на льоту" — відразу після отримання запиту на відкриття файлу,

Каталог `/proc` містить тільки два типи файлів:

1. Інформаційні файли — дають змогу отримувати інформацію про систему та про процеси. Доступні тільки для читання.
2. Керуючі файли — використовується для передачі інформації ядру або його модулям.

```bash
# Загальна інформація про систему
/proc/version
/proc/cpuinfo
/proc/meminfo

# Інформація щодо окремого процесу
/proc/$pid/
```

Кожен процес має відповідну йому директорію в `/proc/<PID>`:

- `cwd` — посилання на поточний каталог процесу
- `cmdline` — містить команду з параметрами за допомогою якої було запущено процес
- `environ` — змінні оточення, доступні для процесу
- `fd` — директорія зі списком файлових дескрипторів
- `exe` — посилання на виконуваний файл
- `sched` — детальна інформація про планувальника, включно з політикою планування, пріоритетом та іншим
- `schedstat` — статистика планировщика, наприклад, кількість часу виконання і часу очікування в черзі
- `stat` — машинозчитуваний файл стану процесу, статистика використання ресурсів та інше
- `status` — файл із детальною інформацією про процес
- `maps, statm, і mem` — інформація про пам'ять процесу

Зміна параметрів ядра на льоту `/proc/sys` або за допомогою програми `sysctl`:

- `debug`— містить налагоджувальну інформацію, вона буде вам корисна якщо ви розробник ядра
- `dev` — параметри різних пристроїв, підключених до системи
- `fs` — вся інформація про файлову систему
- `kernel` — дозволяє безпосередньо налаштовувати ядро
- `net` — налаштування різних параметрів мережі
- `vm` — взаємодія з підсистемою vm

### Моніторинг та керування процесами

#### Базові команди та утиліти

##### Класичні засоби огляду

**`ps`** — (Process Status) виводить знімок інформації про поточні процеси

Робить "знімок" інформації про процеси на момент виконання, і відображає прапори стану, ідентифікатори, використання ресурсів та інші системні дані. Докладніше — **`man ps`**.

Основні ключі:

- **`-e`** — інформація про всі процеси
- **`-a`** — інформація про всі процеси, крім групи процесів та тих, що не мають керуючого терміналу (_tty_)
- **`-x`** — інформація про процеси, які не мають керуючого терміналу
- **`-f`** — детальний формат виведеного списку (full format)
- **`-l`** — виведення у форматі довгого списку (long format)
- **`-o`** — задати користувацький вивід, вказавши бажані поля для відображення
- **`-u`** — виведення інформації про користувача, який запустив процес

```bash
# Процеси поточного користувача
ps -lf

# Відобразити всі, в тому числі й системні
ps -elf

# Більш інформативний звіт
ps -aux | head
```

Опис деяких полів

- **`UID`** (User ID) — ідентифікатор поточного власника процесу
- **`PID`** (Process ID) — унікальний числовий ідентифікатор, що однозначно ідентифікує процес (PID = 0 — (kernel), PID = 1 — (systemd) це батько для всіх інших процесів, крім процесів ядра)
- **`PPID`** (Paren PID) — ідентифікатор батьківського процесу
- **`TTY`** (Terminal) — керуючий термінал, можливо псевдотермінал (pts) або консоль (tty), дивись команди **`who`** або **`w`**
- **`CMD`** (Command) — команда, що запустила процес, назва виконуваного файлу й аргументи рядка запуску
- **`TIME`** (CPU Time) — загальний час використання процесора
- **`%CPU`** (CPU Usage) — відсоткове використання процесора даним процесом
- **`%MEM`** (Memory Usage) — відсоток використання оперативної пам'яті
- **`STAT`** (Status) — маркер поточного статусу процесу
- **`USER`** (Username) — ім'я користувача, від якого виконується процес
- **`PPID`** (Parent Process ID) — ідентифікатор батьківського процесу
- **`VSZ`** (Virtual Size) — розмір віртуальної пам'яті, вся пам'ять, до якої може отримати доступ
- **`RSS`** (Resident Set Size) — розмір резидентного набору, розмір займаний в оперативній пам'яті зараз

Маркери стану процесу — **`STAT`** (Status)

- **`R`** (Running) — виконується або готовий до виконання
- **`S`** (Sleeping) — спить/неактивний, очікує події або завершення операції введення-виведення
- **`I`** (Idle) — процес перебуває в стані простою та не активний
- **`D`** (Uninterruptible Sleep) — призупинений, очікує завершення блокуючої операції введення-виведення, і його не можливо перервати
- **`T`** (Stopped) — зупинений, наприклад, за допомогою сигналу SIGSTOP або SIGTSTP
- **`Z`** (Zombie) — зомбі, процес завершився, але його статус завершення ще не прочитаний батьківським процесом
- **`t`** (Traced) — трасування/дебаг, процес відстежується, наприклад, за допомогою відладчика
- **`W`** (Paging) — сторінки пам'яті процесу вивантажено на диск
- **`L`** (Locked) — процес заблокований в пам'яті
- **`<`** (High priority) — процес має підвищений пріоритет
- **`N`** (Low priority) — процес має знижений пріоритет
- **`X`** (Dead) — процес виконався, але не вивантажився з пам'яті
- **`s`** (session leader) — лідер сесії

**`pstree`** — (Process Status Tree) відображає деревоподібну структуру ієрархії процесів

Синтаксис: `pgrep [опції] [шаблон]`

**`pgrep`** — (Process GREP) пошук процесів за іменами або іншими атрибутами

Синтаксис: `pgrep [опції] [шаблон]`

```bash
# Дізнатися ідентифікатор процесу (PID) для всіх `ssh`
pgrep ssh

# Альтернатива
ps aux | grep -v grep | grep ssh | awk '{print $2}'
```

**`getpcaps`** — (Get Capabilities) перегляд спеціальних привілеїв для процесів за їхнім PID

```bash
# Перегляд привілеїв для всіх процесів `systemd`
getpcaps $(pgrep systemd)
```

##### Створення та керування процесами

**`nohup`** — створення умов фонового виконання програм без прив'язки до терміналу

Синтаксис: `nohup команда [аргументи] &`

```bash
# Виконати скрипт без залежності від терміналу
nohup ./myscrypt.sh &
# Відобразити результат виконання
cat nohup.out
```

**`kill`** — надсилання керуючих сигналів процесам відповідно за PID

Синтаксис: `kill [сигнал] [PID]`

```bash
# Надіслати сигнал SIGTERM процесу з PID 1234
kill 1234

# Надіслати сигнал SIGTERM процесу з PID 5678
kill -9 5678
```

**`pkill`** — надсилання керуючих сигналів процесам відповідно за шаблоном імені

Синтаксис: `pkill [опції] [шаблон]`

```bash
# Надіслати сигнал SIGTERM усім процесам з іменем `firefox`
pkill firefox

# Надіслати сигнал SIGTERM усім процесам з іменем `chrome`
pkill -9 chrome
```

> Альтернатива — **`killall`**, але не працює з шаблонами, а з іменами процесів

##### Керування пріоритетом процесів

**`nice`** — дає змогу запустити процес із заданим пріоритетом

```bash
# Запустити процес `myprocess` з пріоритетом 10
nice -n 10 myprocess
```

**`renice`** — дозволяє змінити пріоритет уже запущених процесів

```bash
# Змінити пріоритет процесу з PID 1234 на 5
renice -n 5 1234
```

**`taskset`** — дозволяє запускати процеси на визначених ядрах процесора

```bash
# Запустити процес `myprocess` на ядрах 0, 1 і 2
taskset -c 0-2 myprocess
```

##### Процеси, пам'ять та файли

- **`lsipc`** — інформація про міжпроцесну взаємодію (IPC) у системі.
  Вона показує інформацію про семафори, повідомлення та пам'ять, що розділяється

- **`lslocks`** — виводить список заблокованих файлів і ID процесів, що їх блокують

- **`lsof`** — список процесів, які відкрили файли або мережеві порти, а також інформацію про них

- **`fuser`** — (File User) упраління процесами та блокуваннями файлів

```bash
# Перегляд процесів, що використовують файл `sshd`
sudo fuser /usr/sbin/sshd

# Показати детальну інформацію про процеси
sudo fuser -v /usr/sbin/cron

# Завершити процеси, що використовують ресурс
fuser -k <шлях_до_ресурсу>
```

#### Перегляд та аналіз системної статистики

**`pidstat`** — інформація про використання процесора процесами

Синтаксис: `pidstat -p [PID]`

**`vmstat`** — інформація про системні ресурси, процеси та віртуальну пам'ять

Синтаксис: `vmstat [опції] [затримка] [лічильник]`

```bash
vmstat      # знімок статистики в момент запуску
vmstat 5    # виводить статистику кожні 5 секунд, перервати — [Alt+C]
vmstat 1 10 # виводить статистику щосекунди протягом 10 секунд
```

#### Максимальне використання CPU та RAM

```bash
# Переглянути Top-10 споживачів CPU
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head
# Переглянути Top-10 споживачів RAM
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head
```

**`mpstat`** — інформація про використання ядер процесора

#### Перегляд процесів у реальному часі

**`top`** — інтерактивне відображення списку процесів у реальному часі

Top також надає інформацію про завантаження системи, пам'ять та інші системні ресурси.
![App-top](images/05-5_App-top.png "App-top")

**`htop`** — утиліта для інтерактивного моніторингу та управління процесами

Вона надає більш дружній інтерфейс з колірним кодуванням і можливістю взаємодії з процесами через контекстне меню.
![App-htop](images/05-6_App-htop.png "App-htop")

```bash
# Встановлення, якщо немає в системі
sudo apt install htop
```

**`glances`** — інтерактивний інструмент моніторингу системи та процесів

Дає змогу відстежувати різні параметри, зокрема використання ЦП, пам'ять, мережу, диски, процеси та інші системні ресурси.
![App-glances](images/05-7_App-glances.png "App-glances")

**`bpytop`** — інтерактивна командна утиліта моніторингу системи

Написана на Python з використанням бібліотеки Blessed. Надає детальну інформацію про завантаження процесора, використання пам'яті, мережеву активність, дискову активність та інші системні ресурси.
![App-bpytop](images/05-8_App-bpytop.png "App-bpytop")
