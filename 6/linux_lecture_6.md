# Розділ 6: Сценарії оболонки

## Основи сценаріїв оболонки

Сценарії оболонки зазвичай починаються з рядка, що містить інформацію про оболонку, яка використовується для їх виконання. Наприклад, якщо ви створили файл з наступним вмістом:

```bash
#!/bin/bash
```

то це означає, що сценарій буде виконуватися в оболонці bash. Якщо ви використовуєте оболонку zsh, то ви можете вказати це в першому рядку сценарію:

```bash
#!/bin/zsh
```

Після цього рядка можуть йти коментарі, які починаються з символу #. Наприклад:

```bash
#!/bin/bash
# Це сценарій, який виводить поточний час
date
```

Частина `#!` називається шебанг (shebang). Вона вказує операційній системі, яка оболонка повинна використовуватися для виконання сценарію. Після шебангу слідує повний шлях до оболонки. Наприклад, `#!/bin/bash` вказує на використання оболонки bash, а `#!/bin/zsh` - на використання оболонки zsh.

Щоб запустити сценарій, вам потрібно надати йому права на виконання. Це можна зробити за допомогою команди `chmod`:

```bash
chmod +x script.sh
```

Тепер ви можете запустити сценарій, використовуючи команду через релятивний шлях `./`:

```bash
./script.sh
```

### Обмеження сценаріїв оболонки

Сценаріїї оболонки добре підходять для автоматизації рутинних завдань, таких як копіювання файлів, виведення інформації про систему, тощо.

Однак вони мають свої обмеження. Наприклад, вони не підтримують багатозадачність, тобто вони не можуть виконувати кілька команд одночасно. Також вони не підтримують обробку винятків, тобто вони не можуть відновлювати роботу після помилки. Це означає, що якщо виникає помилка, то виконання сценарію припиняється.

Також майте на увазі, що сценарії мають залишатися простими. Якщо вони стають складними, то краще використовувати інші мови програмування, такі як Python, Ruby, тощо.

## Лапки та літерали

Припустимо, ви хочете вивести строку `$100`. Якщо ви використовуєте наступний сценарій:

```bash
#!/bin/bash
echo $100
```

то ви отримаєте наступний результат:

```bash
00
```

Це трапляється через те, що оболонка вважає `$1` змінною, а `00` текстом. Спробуємо помістити текст у лапки:

```bash
#!/bin/bash
echo "$100"
```

Проте це не допоможе. Ви отримаєте такий самий результат. Давайте спробуємо помістити текст у одинарні лапки:

```bash
#!/bin/bash
echo '$100'
```

Тепер ви отримаєте очікуваний результат:

```bash
$100
```

### Літерали

Використовуючи лапки, ви створюєте літерали. Літерали - це значення, які ви вводите в сценарій. Вони можуть бути числами, рядками, символами, тощо. Літерали можуть бути вказані у вигляді чисел, рядків, символів, тощо. Наприклад, `100` - це літерал, `Hello, world!` - це літерал, `a` - це літерал.

Перед виконанням сценарію оболонка замінює змінні на їх значення. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
#!/bin/bash
name="John"
echo "Hello, $name"
```

, то оболонка замінить `$name` на `John` і запустить команду `echo "Hello, John"`.

### Одинарні лапки

Найпростіший спосіб змусити оболонку залишити строку без змін - це використовувати одинарні лапки. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
grep 'r.*t' file.txt
```

, то оболонка не замінить `.*` на їх значення.

Весь текст в одинарних лапках вважається одним параметром. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
grep 'r.*t file.txt'
```

, то оболонка вважатиме, що `r.*t file.txt` - це один параметр, а не два.

### Подвійні лапки

Подвійні лапки працюють так само, як і одинарні, за винятком того, що вони дозволяють використовувати змінні. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
#!/bin/bash
name="John"
echo "Hello, $name"
```

, то оболонка замінить `$name` на `John` і запустить команду `echo "Hello, John"`.

### Літерал з лапками

Якщо ви хочете використати лапки в літералі, то ви можете використовувати одинарні лапки всередині подвійних лапок, або навпаки. Наприклад, правильним є наступний варіант:

```bash
#!/bin/bash
echo "It's a beautiful day"
```

Альтернативний метод -- використовувати екранування через символ `\`. Наприклад:

```bash
#!/bin/bash
echo 'It\'s a beautiful day'
```

## Спеціальні змінні

Оболонка має спеціальні змінні, які використовуються для зберігання інформації про виконання сценарію. Наприклад, змінна `$0` містить ім'я сценарію, а змінна `$1` містить перший параметр, переданий сценарію.

### Змінна $0

Змінна `$0` містить ім'я сценарію. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
#!/bin/bash
echo "The name of this script is $0"
```

, то ви отримаєте наступний результат:

```bash
The name of this script is ./script.sh
```

(якщо ім'я сценарію `script.sh`)

### Змінна $1, $2, $3, тощо

Змінні `$1`, `$2`, `$3`, тощо містять параметри, передані сценарію. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
#!/bin/bash
echo "The first parameter is $1"
echo "The second parameter is $2"
```

, і запустите його так:

```bash
./script.sh hello world
```

, то ви отримаєте наступний результат:

```bash
The first parameter is hello
The second parameter is world
```

Якщо ви не передали параметр, то змінна буде порожнім рядком.

Ви можете використовувати вбудовану команду `shift`, щоб видалити перший параметр та посунути всі інші параметри на одну позицію. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
#!/bin/bash
echo "The first parameter is $1"
shift
echo "The first parameter is now $1"
```

, і запустите його так:

```bash
./script.sh hello world
```

, то ви отримаєте наступний результат:

```bash
The first parameter is hello
The first parameter is now world
```

### Кількість аргументів `$#`

Змінна `$#` містить кількість параметрів, переданих сценарію.

### Всі аргументи `$@`

Змінна `$@` містить всі параметри, передані сценарію. Наприклад, якщо ви використовуєте наступний сценарій:

```bash
#!/bin/bash
echo "All parameters are $@"
```

, і запустите його так:

```bash
./script.sh hello world
```

, то ви отримаєте наступний результат:

```bash
All parameters are hello world
```

### Останній код виходу `$?`

Змінна `$?` містить код виходу останньої виконаної команди. Якщо команда виконалася успішно, то ця змінна містить 0. Якщо команда виконалася з помилкою, то ця змінна містить код помилки.

### ID поточного процесу `$$`

Змінна `$$` містить ID поточного процесу.

## Коди виходу

Код виходу - це ціле число, яке повертається програмою після її виконання. Якщо програма виконалася успішно, то вона повертає 0. Якщо виникла помилка, то вона повертає ненульове значення.

По замовчуванню, код виходу сценарію буде кодом виходу останньої виконаної команди. Однак, ви можете встановити код виходу вручну, використовуючи вбудовану команду `exit`. Наприклад, якщо ви хочете явно вказати на помилку, то ви можете використати наступний сценарій:

```bash
#!/bin/bash

# Якщо не вказано параметр, то вивести повідомлення про помилку

if [ -z "$1" ]; then
  echo "Usage: $0 <name>"
  exit 1
fi

echo "Hello, $1"
```

## Умовні оператори

У оболонці Bourne shell (sh) є кілька умовних операторів, які дозволяють вам виконувати різні дії в залежності від умови. Наприклад, ви можете використовувати оператор `if`, щоб виконати команду, якщо умова виконується, або оператор `case`, щоб виконати команду, якщо умова виконується.

Розглянемо приклад використання оператора `if`.

```bash
#!/bin/bash

if [ $1 = hi ]; then
    echo 'The first argument was "hi"'
else
    echo -n 'The first argument was not "hi" -- '
    echo It was '"'$1'"'
fi

```

Тут, слова `if`, `then`, `else`, `fi` -- це ключові слова, а решта -- це команди.

Умова в квадратних дужках `[ $1 = hi ]` перевіряє, чи рівний перший аргумент `hi`. Якщо умова виконується, то виконується перша команда, якщо ні -- друга.

Насправді, символи `[` та `]` -- це команди, які приймають параметри. Вони повертають 0, якщо умова виконується, та ненульове значення, якщо ні. Інше ім'я для команди `[` -- `test`.

Розглянемо як працює попередній приклад:

1. Виконується команда `[ $1 = hi ]` і отримує код виходу.

2. Якщо код виходу 0, то виконується частина, що йде після `then` до `else` або `fi`.

3. Якщо код виходу не 0, то виконується частина, що йде після `else` до `fi`.

4. Умовний оператор завершується словом `fi`.

Через те, що `[` -- це команда, ми використали `;` як маркер кінця команди. Ви можете використовувати `;` для розділення команд, або використовувати новий рядок.

### Помилка Empty Parameter Lists

В попередньому прикладі, якщо користувач не вказав жодного параметра, то ви отримаєте помилку. Щоб цього уникнути, ви можете заключити змінну в подвійні лапки:

```bash
#!/bin/bash

if [ "$1" = hi ]; then
    echo 'The first argument was "hi"'
else
    echo -n 'The first argument was not "hi" -- '
    echo It was '"'$1'"'
fi
```

### Інші команди перевірки умови

Ви можете використовувати будь-яку команду, яка повертає код виходу, в операторі `if`. Наприклад, ви можете використовувати команду `grep` для пошуку тексту в файлі:

```bash
#!/bin/bash

if grep -q "hello" file.txt; then
    echo "The word 'hello' was found in file.txt"
else
    echo "The word 'hello' was not found in file.txt"
fi
```

### Ключове слово elif

Ви можете використовувати ключове слово `elif`, щоб перевірити іншу умову, якщо перша умова не виконується:

```bash
#!/bin/bash

if [ "$1" = hi ]; then
    echo 'The first argument was "hi"'
elif [ "$1" = hello ]; then
    echo 'The first argument was "hello"'
else
    echo -n 'The first argument was not "hi" or "hello" -- '
    echo It was '"'$1'"'
fi
```

### Логічні конструкції

Ви можете використовувати логічні конструкції, такі як `&&` (логічне І) та `||` (логічне АБО), для об'єднання умов:

```bash
#!/bin/bash

if [ "$1" = hi ] && [ "$2" = world ]; then
    echo 'The first argument was "hi" and the second argument was "world"'
else
    echo 'The first argument was not "hi" and the second argument was not "world"'
fi
```

Команда `test` (або `[`) підтримує також свої власні логічні конструкції. Ви можете використовувати `-o` (логічне АБО) та `-a` (логічне І) для об'єднання умов:

```bash
#!/bin/bash

if [ "$1" = hi -a "$2" = world ]; then
    echo 'The first argument was "hi" and the second argument was "world"'
else
    echo 'The first argument was not "hi" and the second argument was not "world"'
fi
```

Також ви можете інвертувати умову, використовуючи `!`:

```bash
#!/bin/bash

if [ ! "$1" = hi ]; then
    echo 'The first argument was not "hi"'
else
    echo 'The first argument was "hi"'
fi
```

### Перевірка умов

- Перевірка на рівність строк: `=` (або `!=` для перевірки на нерівність)
- Перевірка файлів:
  - `-e file` - перевірка наявності файлу
  - `-s file` - перевірка, чи файл не порожній
  - `-f file` - перевірка, чи файл є звичайним файлом
  - `-d file` - перевірка, чи файл є директорією
  - `-h file` - перевірка, чи файл є символічним посиланням
  - `-b file` - перевірка, чи файл є блочним спеціальним файлом
  - `-c file` - перевірка, чи файл є символьним спеціальним файлом
  - `-p file` - перевірка, чи файл є іменованою каналом
  - `-S file` - перевірка, чи файл є сокетом
- Перевірка прав доступу:
  - `-r file` - перевірка, чи файл доступний для читання
  - `-w file` - перевірка, чи файл доступний для запису
  - `-x file` - перевірка, чи файл доступний для виконання
  - `-u file` - перевірка, чи файл має встановлений біт SUID
  - `-g file` - перевірка, чи файл має встановлений біт SGID
  - `-k file` - перевірка, чи файл має встановлений біт sticky
- Бінарні оператори порівняння файлів:
  - `file1 -nt file2` - перевірка, чи file1 новіший за file
  - `file1 -ot file2` - перевірка, чи file1 старіший за file
  - `file1 -ef file2` - перевірка, чи file1 та file2 вказують на один і той же дескриптор `inode`
- Перевірка строк:
  - `-z string` - перевірка, чи строка порожня
  - `-n string` - перевірка, чи строка не порожня
- Перевірка чисел:
  - `int1 -eq int2` - перевірка, чи int1 рівне int2
  - `int1 -ne int2` - перевірка, чи int1 не рівне int2
  - `int1 -lt int2` - перевірка, чи int1 менше int2
  - `int1 -le int2` - перевірка, чи int1 менше або рівне int2
  - `int1 -gt int2` - перевірка, чи int1 більше int2
  - `int1 -ge int2` - перевірка, чи int1 більше або рівне int2

### Тестування стрічок за регулярним виразом

Ви можете використовувати команду `[[` для тестування стрічок за регулярним виразом. Наприклад:

```bash
#!/bin/bash

if [[ "$1" =~ ^[0-9]+$ ]]; then
    echo 'The first argument is a number'
else
    echo 'The first argument is not a number'
fi
```

### Ключове слово case

Ключове слово `case` дозволяє вам перевірити значення змінної та виконати команди в залежності від цього значення. Наприклад:

```bash
#!/bin/bash

case "$1" in
    hi)
        echo 'The first argument was "hi"'
        ;;
    hello)
        echo 'The first argument was "hello"'
        ;;
    what*)
        echo 'The first argument started with "what"'
        ;;
    i|am|groot)
        echo 'The first argument was "i", "am", or "groot"'
        ;;
    *)
        echo -n 'The first argument was not "hi" or "hello" -- '
        echo It was '"'$1'"'
        ;;
esac
```

## Цикли

У оболонці Bourne shell (sh) є кілька циклічних операторів, які дозволяють вам виконувати одні й ті ж команди декілька разів. Наприклад, ви можете використовувати оператор `for`, щоб виконати команди для кожного елемента в списку, або оператор `while`, щоб виконати команди, поки умова виконується.

### Цикл for

Оператор `for` дозволяє вам виконати команди для кожного елемента в списку. Наприклад:

```bash
#!/bin/bash

for i in 1 2 3 4 5
do
    echo "The number is $i"
done
```

Тут слова `for`, `in`, `do`, `done` -- це ключові слова.

Оболонка виконає наступні дії:

1. Встановить змінну `i` на перший (з п'яти) елемент списку, які розділені пробілами й стоять після ключового слова `in`.
1. Виконає команди між `do` та `done` (в цьому випадку викличе команду `echo`).
1. Після виконання всіх команд, повернеться до рядка `for` та встановить змінну `i` на наступний елемент списку. Якщо наступний елемент відсутній, то цикл завершиться.

### Цикл while

В циклі `while` оболонка Борна перевіряє коди виходу так само як і умовний оператор `if`. Наприклад:

```bash
#!/bin/bash

i=1
while [ $i -le 5 ]
do
    echo "The number is $i"
    i=$((i + 1))
done
```

В прикладі перевіряється код виходу програми `test` (`[`). Цикл виконується, поки код виходу стане ненульовим.

Ви також можете вийти з циклу, використовуючи ключове слово `break`.

Також оболонка борна має цикл `until`, який запускає команди, поки умова не виконується (тобто поки код виходу не стане нульовим).

## Підставлення команд

Ви можете використовувати стандартний вивід команд для присвоєння змінній чи передачі іншій команді. Для цього треба огорнути команду в символи `` або `$(...)`. Наприклад:

```bash
#!/bin/bash

files=`ls` # або files=$(ls)
echo $files
```

Всередині команд можна використовувати інші змінні, конвеєри тощо. Проте не варто перебільшувати з підставлення команд, оскільки це може зробити код менш зрозумілим.

Також не варто використовувати `$(ls)`, бо глоб `*` спрацює швидше, ніж запуск окремої команди. Також, при можливості, використовуйте `xargs` або `find -exec`, оскільки вони теж працюють швидше.

## Створення тимчасових файлів

Іноді вам потрібно створити тимчасовий файл для зберігання даних. Для цього ви можете використовувати команду `mktemp`. Наприклад:

```bash
#!/bin/bash

tempfile=$(mktemp)
echo "Temporary file is $tempfile"
```

## Here-документи

Here-документи дозволяють вам передавати великі блоки тексту в команду. Наприклад:

```bash
#!/bin/bash

cat << EOF
Hello, world!
This is a multiline string.
EOF
```

`<< EOF` вказує оболонці перенаправити всі наступні рядки до команди `cat` до тих пір, поки не зустрінеться рядок `EOF`. Замість `EOF` ви можете використовувати будь-яке інше ім'я, проте воно повинно бути однаковим на початку та в кінці та містити лише прописні літери.

В here-документах ви можете використовувати змінні та команди.

## Деякі важливі утиліти

### `basename`

Утиліта `basename` повертає ім'я файлу без шляху. Наприклад:

```bash
basename /usr/bin/ls
```

поверне `ls`.

### `awk`

`awk` -- це потужна мова програмування, проте зараз вона використовується не так часто. Загалом команда `awk` використовується для вибору потрібного поля в потоці даних. Наприклад:

```bash
ls -l | awk '{print $9}'
```

виведе імена файлів у поточній директорії.

### `sed`

`sed` (Stream EDitor) -- це потужний потоковий редактор, який дозволяє вам виконувати різні операції з потоком даних.

Широко розповсюдженою задачею для `sed` є заміна тексту. Наприклад:

```bash
echo "Hello, world!" | sed 's/world/there/'
```

### `expr`

`expr` -- це утиліта, яка дозволяє вам виконувати арифметичні операції в оболонці. Наприклад:

```bash
i=1
expr $i + 1
```

Альтернативою `expr` є конструкція `$((...))`.

Втім обидві версії досить повільні, тому краще використовувати інші мови програмування (наприклад, Python) для арифметичних операцій.

### `exec`

`exec` -- це команда, яка дозволяє вам замінити поточний процес іншим процесом. Наприклад:

```bash
exec ls
```

замінить поточний процес процесом `ls`.

### Підоболонки

Ви можете змінювати середовище оболонки для запуску певної команди, не змінюючи нічого в основному середовищі. Для цього треба створити підоболонку, огорнувши команди круглими дужками:

```bash
(
    export VAR=value
    command1
    command2
)
```

## Додавання файлів в сценарій

Якщо ви хочете виконати код іншого сценарію в поточному сценарії, то ви можете використовувати команду `source` або `.`. Наприклад:

```bash
source script.sh
```

Цей метод називається `сорсінгом` файлу. Є різниця між сорсінгом та запуску такого сценарію, бо при запуску сценарій не видає нічого, крім виводу та коду виходу, а при сорсінгу ви можете використовувати змінні та функції з імпортованого сценарію.

## Функції

Ви можете визначити функції в оболонці, як і в інших мовах програмування. Наприклад:

```bash
#!/bin/bash

hello() {
    echo "Hello, world!"
}

hello
```

Функція -- це послідовність команд, які виконуються при виклику функції (за її ім'ям). Ви можете передавати параметри функції, як і в іншій частині сценарію. Наприклад:

```bash
#!/bin/bash

hello() {
    echo "Hello, $1!"
}

hello world
```

Синтаксис функцій може включати ключове слово `function`, проте воно не є обов'язковим.

## Читання користувацького вводу

Ви можете читати користувацький ввід в оболонці та зберігати його в змінній за допомогою команди `read`. Наприклад:

```bash
#!/bin/bash

echo "What is your name?"
read name
echo "Hello, $name!"
```
