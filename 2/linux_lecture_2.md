# Розділ 2. Загальна картина

## Рівні абстракції в системі Linux

Рівень абстракції в контексті операційних систем визначає, де цей компонент знаходиться між користувачем і обладнанням. Система Linux має три основні рівні:

- *апаратне забезпечення* (`hardware`)
- *простір ядра* (`kernel space`)
- процеси, які разом складають *простір користувача* (`user space`)

Ядро працює в режимі ядра, де має необмежений доступ до процесора та основної пам'яті. Процеси користувача виконуються в режимі користувача, який обмежує доступ до (зазвичай досить невеликої) підмножини пам’яті та безпечних операцій ЦП.

![Linux levels](images/Figure1-1.png)

## Обладнання: розуміння основної пам'яті

Запущене ядро та процеси зберігаються в пам’яті (найважливіша частина апаратного забезпечення), ЦП – це лише менеджер пам’яті, який допомагає процесу змінювати свій стан (`state`).

`State` у відношенні до пам'яті – це певне розташування бітів.

![Process memory alignment](images/process_memory.png)

## Ядро

Одним із завдань ядра є розділення пам’яті на багато розділів, і воно має постійно підтримувати певну інформацію про стан цих розділів. Ядро відповідає за керування завданнями в чотирьох загальних областях системи:

- **Процеси**: визначає, яким процесам дозволено використовувати ЦП
- **Пам'ять**: відстежує всю пам'ять, наразі виділену певному процесу, спільну між процесами або вільну
- **Драйвери пристроїв**: шукає та виконує код драйверів, які працюють як інтерфейс між обладнанням (наприклад, диском) і процесами
- **Системні виклики** та підтримка: опрацьовує системні виклики, які процеси зазвичай використовують для зв’язку з ядром

Ядро в певному сенсі можна уявляти як (досить складну) програму. Переглянути інформацію про версію ядра можна за допомогою команди `uname`:

```bash
$ uname -rs
Linux 5.4.0-42-generic
```

### Управління процесами

Управління процесами відповідає за запуск, призупинення, відновлення та завершення процесів. Коли один процес передає контроль над ЦП іншому, це називають перемиканням контексту (і за це відповідає ядро).

![Context switching](images/context_switching.webp)

Переглянути всі процеси, які виконуються в системі, можна за допомогою команди `ps`:

```bash
$ ps -aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  22576  5640 ?        Ss   15:59   0:00 /sbin/init
root         2  0.0  0.0      0     0 ?        S    15:59   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        I<   15:59   0:00 [rcu_gp]
root         4  0.0  0.0      0     0 ?        I<   15:59   0:00 [rcu_par_gp]
root         6  0.0  0.0      0     0 ?        I<   15:59   0:00 [kworker/0:0H-kblockd]
```

### Керування пам'яттю

Ядро має керувати пам’яттю під час перемикання контексту, для цього ЦП використовує блок керування пам’яттю (`MMU`), який діє як посередник між пам’яттю процесу та фізичним розташуванням самої пам’яті (реалізація мапи адрес пам’яті називається *таблицею сторінок* (`page table`)).

![Virtual memory](images/virtual_memory.jpg)

Перевірити використання пам’яті можна за допомогою команди `free`:

```bash
$ free -h
              total        used        free      shared  buff/cache   available
Mem:           7.7G        1.3G        5.1G        1.1M        1.3G        6.2G
Swap:          2.0G          0B        2.0G
```

### Драйвери пристроїв і керування ними

Пристрій зазвичай доступний лише в режимі ядра, оскільки неправильний доступ може призвести до збою машини та неправильній комунікації між інтерфейсами програмування пристроїв.

### Системні виклики та підтримка

Системні виклики (`syscalls`) виконують конкретні завдання, які процес користувача сам по собі не може виконати або виконати добре. Два важливі системні виклики:

- `fork()`: виклик, який створює майже ідентичну копію процесу.
- `exec()`: коли процес викликає `exec(program)`, ядро запускає програму, замінюючи поточний процес.

![Linux process creation](images/Figure1-2.png)

Окрім сервісу `init`, усі користувацькі процеси в системі Linux запускаються як результат `fork()`, і здебільшого також запускають `exec()`, щоб запустити нову програму замість копії наявного процесу.

Переглянути дерево процесів можна за допомогою команди `pstree`.

## Простір користувача

Основна пам'ять, яку ядро виділяє для процесів користувача, називається простором користувача.

Оскільки процес — це просто стан (або образ) у пам’яті, простором користувача також називають ділянку пам'яті, де виконуються всі запущені в просторі користувача процеси.

![Linux user space](images/Figure1-3.png)

## Монолітна та мікроядерна архітектури

### Монолітна архітектура

**Монолітна архітектура** означає, що операційна система побудована як єдиний великий блок коду, де всі основні сервіси, такі як управління пам'яттю, файлові системи, драйвери пристроїв та мережеві стеки, працюють в режимі ядра.

#### Переваги монолітної архітектури

1. **Продуктивність**: Всі системні виклики відбуваються швидко, оскільки всі сервіси знаходяться в одному адресному просторі.
2. **Менше контекстних перемикань**: Оскільки сервіси не розділені на різні процеси, операційна система потребує менше перемикань контексту між режимами користувача та ядра.
3. **Простота розробки**: Для розробників зручніше мати єдине велике ядро, де всі частини системи легко взаємодіють між собою.

#### Недоліки монолітної архітектури

1. **Надійність**: Помилка в будь-якій частині ядра може призвести до краху всієї системи.
2. **Розширюваність**: Додавання нових функцій може бути складним, оскільки це вимагає внесення змін у вже наявний великий код.
3. **Безпека**: Всі частини ядра мають доступ до всього пам'яті ядра, що збільшує ризик атак.

### Мікроядерна архітектура

**Мікроядерна архітектура** передбачає, що ядро виконує лише основні функції, такі як управління процесами та комунікація між процесами, тоді як всі інші сервіси (файлові системи, драйвери пристроїв тощо) працюють у вигляді окремих процесів в режимі користувача.

#### Переваги мікроядерної архітектури

1. **Модульність**: Легше додавати нові сервіси або змінювати чинні без ризику впливу на основне ядро.
2. **Безпека**: Кожен сервіс працює у своєму власному адресному просторі, що зменшує ризик від атак.
3. **Надійність**: Збої в одному з сервісів не призводять до краху всієї системи, оскільки ядро та інші сервіси продовжують працювати.

#### Недоліки мікроядерної архітектури

1. **Продуктивність**: Більше контекстних перемикань між режимами користувача та ядра, що уповільнює роботу системи.
2. **Ускладненість комунікацій**: Сервіси повинні взаємодіяти через міжпроцесорне спілкування (IPC), що також впливає на продуктивність.
3. **Складність розробки**: Розробка мікроядерних систем вимагає більше зусиль через необхідність забезпечення ефективного IPC та управління незалежними сервісами.

![Monolithic vs microkernel](images/kernel.jpg)

### Чому Linux монолітний?

Лінукс обрав монолітну архітектуру з кількох причин:

1. **Продуктивність**: Як вже зазначалося, монолітні ядра зазвичай забезпечують кращу продуктивність завдяки меншій кількості контекстних перемикань та швидшому доступу до сервісів ядра.
2. **Простота розробки**: Для розробників простіше працювати з єдиним великим ядром, оскільки всі частини коду можуть взаємодіяти без додаткових механізмів комунікації.
3. **Історична спадщина**: Unix-подібні системи, на яких базується Linux, завжди використовували монолітні ядра. Ця традиція була продовжена в Linux.
4. **Потреби користувачів**: На момент створення Linux, користувачі та розробники потребували високопродуктивної операційної системи з можливістю легкого додавання нових функцій, що було легше реалізувати в монолітному ядрі.

## Користувачі

Користувач — це суб’єкт, який може запускати процеси та володіти файлами. Користувач пов’язаний з `username`, але ядро не керує іменами користувачів, натомість воно ідентифікує користувачів простими числовими ідентифікаторами, що називаються `userids`.

![Linux user ID](images/uid.webp)

Користувачі існують насамперед для підтримки системи дозволів і обмежень. Кожен процес простору користувача має користувача власника, і кажуть, що процеси запускаються від імені власника.

Групи — це набори користувачів. Основна їхня мета — дозволити користувачеві надавати доступ до файлів іншим користувачам у групі.

Переглянути вашого поточного користувача та групу можна за допомогою команди `id`:

```bash
$ id
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd),118(lpadmin),119(sambashare)
```

Переглянути ім'я поточного користувача можна за допомогою команди `whoami`:

```bash
$ whoami
ubuntu
```

Переглянути всіх користувачів, які мають активні сесії, можна за допомогою команди `w` (або `who`):

```bash
$ w
 16:00:00 up  1:00,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
ubuntu   tty1                      15:59    1:00   0.00s  0.00s -bash
```
