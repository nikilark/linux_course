## Розділ 11: Сценарії оболонки
### Основи сценаріїв оболонки
Сценарії оболонки зазвичай починаються з рядка, що містить інформацію про оболонку, яка використовується для їх виконання. Наприклад, якщо ви створили файл з наступним вмістом:
```bash
#!/bin/bash
```
то це означає, що сценарій буде виконуватися в оболонці bash. Якщо ви використовуєте оболонку zsh, то ви можете вказати це в першому рядку сценарію:
```bash
#!/bin/zsh
```

Після цього рядка можуть йти коментарі, які починаються з символу #. Наприклад:
```bash
#!/bin/bash
# Це сценарій, який виводить поточний час
date
```

Частина `#!` називається шебанг (shebang). Вона вказує операційній системі, яка оболонка повинна використовуватися для виконання сценарію. Після шебангу слідує повний шлях до оболонки. Наприклад, `#!/bin/bash` вказує на використання оболонки bash, а `#!/bin/zsh` - на використання оболонки zsh.

Щоб запустити сценарій, вам потрібно надати йому права на виконання. Це можна зробити за допомогою команди `chmod`:
```bash
chmod +x script.sh
```

Тепер ви можете запустити сценарій, використовуючи команду через релятивний шлях `./`:
```bash
./script.sh
```

#### Обмеження сценаріїв оболонки
Сценаріїї оболонки добре підходять для автоматизації рутинних завдань, таких як копіювання файлів, виведення інформації про систему, тощо.

Однак вони мають свої обмеження. Наприклад, вони не підтримують багатозадачність, тобто вони не можуть виконувати кілька команд одночасно. Також вони не підтримують обробку винятків, тобто вони не можуть відновлювати роботу після помилки. Це означає, що якщо виникає помилка, то виконання сценарію припиняється.

Також майте на увазі, що сценарії мають залишатися простими. Якщо вони стають складними, то краще використовувати інші мови програмування, такі як Python, Ruby, тощо.

### Лапки та літерали

Припустимо, ви хочете вивести строку `$100`. Якщо ви використовуєте наступний сценарій:
```bash
#!/bin/bash
echo $100
```
то ви отримаєте наступний результат:
```bash
00
```

Це трапляється через те, що оболонка вважає `$1` змінною, а `00` текстом. Спробуємо помістити текст у лапки:
```bash
#!/bin/bash
echo "$100"
```
Проте це не допоможе. Ви отримаєте такий самий результат. Давайте спробуємо помістити текст у одинарні лапки:
```bash
#!/bin/bash
echo '$100'
```
Тепер ви отримаєте очікуваний результат:
```bash
$100
```

#### Літерали

Використовуючи лапки, ви створюєте літерали. Літерали - це значення, які ви вводите в сценарій. Вони можуть бути числами, рядками, символами, тощо. Літерали можуть бути вказані у вигляді чисел, рядків, символів, тощо. Наприклад, `100` - це літерал, `Hello, world!` - це літерал, `a` - це літерал.

Перед виконанням сценарію оболонка замінює змінні на їх значення. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
#!/bin/bash
name="John"
echo "Hello, $name"
```
, то оболонка замінить `$name` на `John` і запустить команду `echo "Hello, John"`.

#### Одинарні лапки

Найпростіший спосіб змусити оболонку залишити строку без змін - це використовувати одинарні лапки. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
grep 'r.*t' file.txt
```
, то оболонка не замінить `.*` на їх значення.

Весь текст в одинарних лапках вважається одним параметром. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
grep 'r.*t file.txt'
```
, то оболонка вважатиме, що `r.*t file.txt` - це один параметр, а не два.

#### Подвійні лапки

Подвійні лапки працюють так само, як і одинарні, за винятком того, що вони дозволяють використовувати змінні. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
#!/bin/bash
name="John"
echo "Hello, $name"
```
, то оболонка замінить `$name` на `John` і запустить команду `echo "Hello, John"`.

#### Літерал з лапками

Якщо ви хочете використати лапки в літералі, то ви можете використовувати одинарні лапки всередині подвійних лапок, або навпаки. Наприклад, правильним є наступний варіант:
```bash
#!/bin/bash
echo "It's a beautiful day"
```

Альтернативний метод -- використовувати екранування через символ `\`. Наприклад:
```bash
#!/bin/bash
echo 'It\'s a beautiful day'
```

### Спеціальні змінні

Оболонка має спеціальні змінні, які використовуються для зберігання інформації про виконання сценарію. Наприклад, змінна `$0` містить ім'я сценарію, а змінна `$1` містить перший параметр, переданий сценарію.

#### Змінна $0

Змінна `$0` містить ім'я сценарію. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
#!/bin/bash
echo "The name of this script is $0"
```
, то ви отримаєте наступний результат:
```bash
The name of this script is ./script.sh
```
(якщо ім'я сценарію `script.sh`)

#### Змінна $1, $2, $3, тощо

Змінні `$1`, `$2`, `$3`, тощо містять параметри, передані сценарію. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
#!/bin/bash
echo "The first parameter is $1"
echo "The second parameter is $2"
```
, і запустите його так:
```bash
./script.sh hello world
```
, то ви отримаєте наступний результат:
```bash
The first parameter is hello
The second parameter is world
```
Якщо ви не передали параметр, то змінна буде порожнім рядком.

Ви можете використовувати вбудовану команду `shift`, щоб видалити перший параметр та посунути всі інші параметри на одну позицію. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
#!/bin/bash
echo "The first parameter is $1"
shift
echo "The first parameter is now $1"
```
, і запустите його так:
```bash
./script.sh hello world
```
, то ви отримаєте наступний результат:
```bash
The first parameter is hello
The first parameter is now world
```

#### Кількість аргументів `$#`

Змінна `$#` містить кількість параметрів, переданих сценарію.

#### Всі аргументи `$@`

Змінна `$@` містить всі параметри, передані сценарію. Наприклад, якщо ви використовуєте наступний сценарій:
```bash
#!/bin/bash
echo "All parameters are $@"
```
, і запустите його так:
```bash
./script.sh hello world
```
, то ви отримаєте наступний результат:
```bash
All parameters are hello world
```

#### Останній код виходу `$?`

Змінна `$?` містить код виходу останньої виконаної команди. Якщо команда виконалася успішно, то ця змінна містить 0. Якщо команда виконалася з помилкою, то ця змінна містить код помилки.

#### ID поточного процесу `$$`

Змінна `$$` містить ID поточного процесу.

### Коди виходу

Код виходу - це ціле число, яке повертається програмою після її виконання. Якщо програма виконалася успішно, то вона повертає 0. Якщо виникла помилка, то вона повертає ненульове значення.

По замовчуванню, код виходу сценарію буде кодом виходу останньої виконаної команди. Однак, ви можете встановити код виходу вручну, використовуючи вбудовану команду `exit`. Наприклад, якщо ви хочете явно вказати на помилку, то ви можете використати наступний сценарій:
```bash
#!/bin/bash

# Якщо не вказано параметр, то вивести повідомлення про помилку

if [ -z "$1" ]; then
  echo "Usage: $0 <name>"
  exit 1
fi

echo "Hello, $1"
```

### Умовні оператори

У оболонці Bourne shell (sh) є кілька умовних операторів, які дозволяють вам виконувати різні дії в залежності від умови. Наприклад, ви можете використовувати оператор `if`, щоб виконати команду, якщо умова виконується, або оператор `case`, щоб виконати команду, якщо умова виконується.

Розглянемо приклад використання оператора `if`.
```bash
#!/bin/bash

if [ $1 = hi ]; then
    echo 'The first argument was "hi"'
else
    echo -n 'The first argument was not "hi" -- '
    echo It was '"'$1'"'
fi

```

Тут, слова `if`, `then`, `else`, `fi` -- це ключові слова, а решта -- це команди.

Умова в квадратних дужках `[ $1 = hi ]` перевіряє, чи рівний перший аргумент `hi`. Якщо умова виконується, то виконується перша команда, якщо ні -- друга.

Насправді, символи `[` та `]` -- це команди, які приймають параметри. Вони повертають 0, якщо умова виконується, та ненульове значення, якщо ні. Інше ім'я для команди `[` -- `test`.

Розглянемо як працює попередній приклад:

1. Виконується команда `[ $1 = hi ]` і отримує код виходу.

2. Якщо код виходу 0, то виконується частина, що йде після `then` до `else` або `fi`.

3. Якщо код виходу не 0, то виконується частина, що йде після `else` до `fi`.

4. Умовний оператор завершується словом `fi`.

Через те, що `[` -- це команда, ми використали `;` як маркер кінця команди. Ви можете використовувати `;` для розділення команд, або використовувати новий рядок.

#### Помилка Empty Parameter Lists

В попередньому прикладі, якщо користувач не вказав жодного параметра, то ви отримаєте помилку. Щоб цього уникнути, ви можете заключити змінну в подвійні лапки:
```bash
#!/bin/bash

if [ "$1" = hi ]; then
    echo 'The first argument was "hi"'
else
    echo -n 'The first argument was not "hi" -- '
    echo It was '"'$1'"'
fi
```

#### Інші команди перевірки умови

Ви можете використовувати будь-яку команду, яка повертає код виходу, в операторі `if`. Наприклад, ви можете використовувати команду `grep` для пошуку тексту в файлі:
```bash
#!/bin/bash

if grep -q "hello" file.txt; then
    echo "The word 'hello' was found in file.txt"
else
    echo "The word 'hello' was not found in file.txt"
fi
```

#### Ключове слово elif

Ви можете використовувати ключове слово `elif`, щоб перевірити іншу умову, якщо перша умова не виконується:
```bash
#!/bin/bash

if [ "$1" = hi ]; then
    echo 'The first argument was "hi"'
elif [ "$1" = hello ]; then
    echo 'The first argument was "hello"'
else
    echo -n 'The first argument was not "hi" or "hello" -- '
    echo It was '"'$1'"'
fi
```

#### Логічні конструкції

Ви можете використовувати логічні конструкції, такі як `&&` (логічне І) та `||` (логічне АБО), для об'єднання умов:
```bash
#!/bin/bash

if [ "$1" = hi ] && [ "$2" = world ]; then
    echo 'The first argument was "hi" and the second argument was "world"'
else
    echo 'The first argument was not "hi" and the second argument was not "world"'
fi
```

Команда `test` (або `[`) підтримує також свої власні логічні конструкції. Ви можете використовувати `-o` (логічне АБО) та `-a` (логічне І) для об'єднання умов:
```bash
#!/bin/bash

if [ "$1" = hi -a "$2" = world ]; then
    echo 'The first argument was "hi" and the second argument was "world"'
else
    echo 'The first argument was not "hi" and the second argument was not "world"'
fi
```

Також ви можете інвертувати умову, використовуючи `!`:
```bash
#!/bin/bash

if [ ! "$1" = hi ]; then
    echo 'The first argument was not "hi"'
else
    echo 'The first argument was "hi"'
fi
```

#### Перевірка умов

- Перевірка на рівність строк: `=` (або `!=` для перевірки на нерівність)
- Перевірка файлів:
    - `-e file` - перевірка наявності файлу
    - `-s file` - перевірка, чи файл не порожній
    - `-f file` - перевірка, чи файл є звичайним файлом
    - `-d file` - перевірка, чи файл є директорією
    - `-h file` - перевірка, чи файл є символічним посиланням
    - `-b file` - перевірка, чи файл є блочним спеціальним файлом
    - `-c file` - перевірка, чи файл є символьним спеціальним файлом
    - `-p file` - перевірка, чи файл є іменованою каналом
    - `-S file` - перевірка, чи файл є сокетом
- Перевірка прав доступу:
    - `-r file` - перевірка, чи файл доступний для читання
    - `-w file` - перевірка, чи файл доступний для запису
    - `-x file` - перевірка, чи файл доступний для виконання
    - `-u file` - перевірка, чи файл має встановлений біт SUID
    - `-g file` - перевірка, чи файл має встановлений біт SGID
    - `-k file` - перевірка, чи файл має встановлений біт sticky
- Бінарні оператори порівняння файлів:
    - `file1 -nt file2` - перевірка, чи file1 новіший за file
    - `file1 -ot file2` - перевірка, чи file1 старіший за file
    - `file1 -ef file2` - перевірка, чи file1 та file2 вказують на один і той же дескриптор `inode`
- Перевірка строк:
    - `-z string` - перевірка, чи строка порожня
    - `-n string` - перевірка, чи строка не порожня
- Перевірка чисел:
    - `int1 -eq int2` - перевірка, чи int1 рівне int2
    - `int1 -ne int2` - перевірка, чи int1 не рівне int2
    - `int1 -lt int2` - перевірка, чи int1 менше int2
    - `int1 -le int2` - перевірка, чи int1 менше або рівне int2
    - `int1 -gt int2` - перевірка, чи int1 більше int2
    - `int1 -ge int2` - перевірка, чи int1 більше або рівне int2

#### Ключове слово case

Ключове слово `case` дозволяє вам перевірити значення змінної та виконати команди в залежності від цього значення. Наприклад:
```bash
#!/bin/bash

case "$1" in
    hi)
        echo 'The first argument was "hi"'
        ;;
    hello)
        echo 'The first argument was "hello"'
        ;;
    what*)
        echo 'The first argument started with "what"'
        ;;
    i|am|groot)
        echo 'The first argument was "i", "am", or "groot"'
        ;;
    *)
        echo -n 'The first argument was not "hi" or "hello" -- '
        echo It was '"'$1'"'
        ;;
esac
```
